<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2020%2F01%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之 后，再把请求转交给本体对象 案例案例一 在四月一个晴朗的早晨，小明遇见了他的百分百女孩，我们暂且称呼小明的女神为A。两天之后，小明决定给A送一束花来表白。刚好小明打听到A和他有一个共同的朋友 B，于是内向的小明决定让 B来代替自己完成送花这件事情 12345678910111213141516171819202122class Flower &#123;&#125;let xiaoMing = &#123; sendFlower(target) &#123; let flower = new Flower() target.receiveFlower(flower) &#125;&#125;let B = &#123; receiveFlower(flower) &#123; A.receiveFlower(flower) &#125;&#125;let A = &#123; receiveFlower(flower) &#123; console.log('收到' + flower); &#125;&#125;xiaoMing.sendFlower(B) 假设当 A 在心情好的时候收到花，小明表白成功的几率有60%，而当A在心情差的时候收到花，小明表白的成功率无限趋近于 0, 但是 A的朋友 B却很了解 A，所以小明只管把花交给 B，B会监听 A的心情变化，然后选择A心情好的时候把花转交给A， 123456789101112131415161718192021222324252627282930class Flower &#123;&#125;let xiaoMing = &#123; sendFlower(target) &#123; let flower = new Flower() target.receiveFlower(flower) &#125;&#125;let B = &#123; receiveFlower(flower) &#123; // B 监听 A 心情 好时送花 A.listenGoodMood(() =&gt; &#123; A.receiveFlower(flower) &#125;) &#125;&#125;let A = &#123; receiveFlower(flower) &#123; console.log('收到' + flower); &#125;, listenGoodMood(fn) &#123; setTimeout(() =&gt; &#123; fn() &#125;, 10000); &#125;&#125; xiaoMing.sendFlower(B) 保护代理和虚拟代理代理 B 可以帮助 A过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理 B 处被拒绝掉。这种代理叫作保护代理。 另外，假设现实中的花价格不菲，导致在程序世界里，new Flower 也是一个代价昂贵的操作，那么我们可以把 new Flower 的操作交给代理 B去执行，代理 B会选择在 A心情好时再执行 new Flower，这是代理模式的另一种形式，叫作虚拟代理。虚拟代理把一些开销很大的对象，延迟到 真正需要它的时候才去创建 12345678let B = &#123; receiveFlower: function (flower) &#123; A.listenGoodMood(function () &#123; let flower = new Flower(); // 延迟创建 flower 对象 A.receiveFlower(flower); &#125;); &#125; &#125;; 思考： vue-router 中的路由守卫 和 axios 中的 拦截器 是不是 用到了代理模式 虚拟代理实现图片预加载在Web开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张 loading图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里，这种 场景就很适合使用虚拟代理。 非代理模式实现123456789101112131415let imgNode = document.createElement('img') document.body.appendChild(imgNode) let img = new Image // 异步 img.onload = () =&gt; &#123; imgNode.src = img.src &#125; function setSrc(src) &#123; imgNode.src = './图片预加载/14839259814975095.gif' img.src = src &#125; setSrc('https://tse1-mm.cn.bing.net/th?id=OIP.BX8LJipOhUSQQx8GCCplWQHaIM&amp;w=91&amp;h=101&amp;c=8&amp;rs=1&amp;qlt=90&amp;dpr=1.25&amp;pid=3.1&amp;rm=2') 闭包优化 123456789101112131415161718let myImage = (() =&gt; &#123; let imgNode = document.createElement('img') document.body.appendChild(imgNode) let img = new Image img.onload = () =&gt; &#123; imgNode.src = img.src &#125; return &#123; setSrc(src) &#123; imgNode.src = './图片预加载/14839259814975095.gif' img.src = src &#125; &#125; &#125;)() myImage.setSrc('https://tse1-mm.cn.bing.net/th?id=OIP.BX8LJipOhUSQQx8GCCplWQHaIM&amp;w=91&amp;h=101&amp;c=8&amp;rs=1&amp;qlt=90&amp;dpr=1.25&amp;pid=3.1&amp;rm=2') 优点： 用闭包封装后，将变量私有化，使得外部不能直接修改这些变量 代理模式实现12345678910111213141516171819202122232425262728293031let myImage = (function () &#123; let imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();let proxyImage = (function () &#123; // 虚拟代理，帮助我们控制访问创建开销大的资源 let img = new Image; // 异步 img.onload = function () &#123; // 代理转发请求 myImage.setSrc(this.src); &#125; return &#123; setSrc(src) &#123; // 加载loading 图 // 此处可以加载一个本地图片或者缓存过的图片 myImage.setSrc('./图片预加载/14839259814975095.gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('https://tse1-mm.cn.bing.net/th?id=OIP.BX8LJipOhUSQQx8GCCplWQHaIM&amp;w=91&amp;h=101&amp;c=8&amp;rs=1&amp;qlt=90&amp;dpr=1.25&amp;pid=3.1&amp;rm=2'); 虚拟代理合并 HTTP请求 在 Web 开发中，也许最大的开销就是网络请求。假设我们在做一个文件同步的功能，当我们选中一个 checkbox 的时候，它对应的文件就会被同 步到另外一台备用服务器上面 123456789101112&lt;body&gt; &lt;input type="checkbox" id="1"&gt;1 &lt;input type="checkbox" id="2"&gt;2 &lt;input type="checkbox" id="3"&gt;3 &lt;input type="checkbox" id="4"&gt;4 &lt;input type="checkbox" id="5"&gt;5 &lt;input type="checkbox" id="6"&gt;6 &lt;input type="checkbox" id="7"&gt;7 &lt;input type="checkbox" id="8"&gt;8 &lt;input type="checkbox" id="9"&gt;9 不使用代理合并请求 12345678910111213let checkbox = document.getElementsByTagName('input')for (let i = 0; i &lt; checkbox.length; i++) &#123; const c = checkbox[i]; c.addEventListener('click', function() &#123; if (this.checked === true) &#123; asyncFile(this.id) &#125; &#125;)&#125;// 同步数据方法let asyncFile = function (id) &#123; console.log(`同步第$&#123;id&#125; 个`);&#125; checkbox 每选中一个，就好同步一个，如果不停点击，则会不停发送请求同步数据，如此频繁的网络请求将会带来相当大的开销。 使用代理合并请求 12345678910111213141516171819202122232425262728293031323334let checkbox = document.getElementsByTagName('input')for (let i = 0; i &lt; checkbox.length; i++) &#123; const c = checkbox[i]; c.addEventListener('click', function () &#123; if (this.checked === true) &#123; proxySyncFile(this.id) &#125; &#125;)&#125;// 代理let proxySyncFile = (function () &#123; let cache = [], timer return function (id) &#123; cache.push(id) // 保证不会覆盖已经启动的定时器 if (timer) &#123; return &#125; // 每两秒 请求一次 timer = setTimeout(() =&gt; &#123; syncFile(cache.join(',')) timer = null cache.length = 0 &#125;, 2000); &#125;&#125;)()let syncFile = function (id) &#123; console.log(`同步第$&#123;id&#125; 个`);&#125; 用 proxySyncFile 方法 代理 syncFile 方法，将两秒内的请求进行一次合并，统一发送 缓存代理计算乘积 1234567891011121314151617181920212223let mult = function (...arg) &#123; let res = 1 for (let i = 0; i &lt; arg.length; i++) &#123; const e = arg[i]; res = res * e &#125; return res&#125;let proxyMult = (function () &#123; let cache = &#123;&#125; return function (...arg) &#123; let args = arg.join(',') if (args in cache) &#123; return cache[args] &#125; return cache[args] = mult(...arg) &#125;&#125;)()console.log(proxyMult(1,3,4)); 用 proxyMult 代理 mult ，将每次的计算都缓存到 proxyMult 中 扩展 当使用ajax请求分页数据的时候，可以用上面的方法缓存分页数据，减少Ajax 请求]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2019%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 例子 很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为 S的人年终奖有 4倍工资，绩效为A的人年终奖有 3倍工资，而绩效为 B的人年终奖是 2倍工资。假设财 务部要求我们提供一段代码，来方便他们计算员工的年终奖。 简单写法12345678910111213let calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === 'S' ) &#123; return salary * 4 &#125; if (performanceLevel === 'A') &#123; return salary * 3 &#125; if (performanceLevel === 'B') &#123; return salary * 3 &#125;&#125;console.log(calculateBonus('S', 10000)); 缺点分分析： calculateBonus 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的逻辑 分支 calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级 C，或者想把绩效 S 的奖金 系数改为 5，那我们必须深入 calculateBonus函数的内部实现，这是违反开放封闭原则的 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择 只有复制和粘贴 使用策略模式重构代码将不变的部分和变化的部分分隔起来，是每个设计模式的主题 一个基于策略模式的程序至少分为两部分，策略类和环境类 策略类：封装了具体的算法，并负责具体的计算过程 环境类：接受客户的请求，随后把请求委托给一个策略类 关系： 环境类需要维持某个策略类的引用 es6 重构代码 策略类 1234567891011121314151617181920class PerformanceS &#123; constructor() &#123;&#125; calculate(salary) &#123; return salary * 4; &#125;&#125;class PerformanceA &#123; constructor() &#123;&#125; calculate(salary) &#123; return salary * 3; &#125;&#125;class PerformanceB &#123; constructor() &#123;&#125; calculate(salary) &#123; return salary * 2; &#125;&#125; 环境类 123456789101112131415161718192021class Bonus &#123; constructor() &#123; // 原始工资 this.salary = null; // 用于保存 绩效等级对应的策略类 this.strategy = null; &#125; setSalary(salary) &#123; this.salary = salary; &#125; // 保存策略类 setStrategy(strategy) &#123; this.strategy = strategy; &#125; // 调用策略类 getBonus() &#123; return this.strategy.calculate(this.salary); &#125;&#125; 具体调用 12345678let bonus = new Bonus();bonus.setSalary(10000);// 传入策略类bonus.setStrategy(new PerformanceS());console.log(bonus.getBonus()); // 40000bonus.setStrategy(new PerformanceA());console.log(bonus.getBonus()); // 30000 JavaScript版本的策略模式实际上在 JavaScript 语言中，函数也是对象，所以更简单和直接的做法是把 strategy 直接定义为函数 1234567891011121314151617let strategies = &#123; S(salary) &#123; return salary * 4 &#125;, A(salary) &#123; return salary * 3 &#125;, B(salary) &#123; return salart * 2 &#125;&#125;let calculateBonus = (level, salary) =&gt; &#123; return strategies[level](salary)&#125;console.log(calculateBonus('S', 1000)) // 4000 策略模式验证表单html 表单 123456&lt;form action="http:// xxx.com/register" id="registerForm" method="post"&gt; 请输入用户名：&lt;input type="text" name="userName" /&gt; 请输入密码：&lt;input type="text" name="password" /&gt; 请输入手机号码：&lt;input type="text" name="phoneNumber" /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 无策略模式的表单校验123456789101112131415let registerForm = document.getElementById('registerForm');registerForm.onsubmit = function () &#123; if (registerForm.userName.value === '') &#123; alert('用户名不能为空'); return false; &#125; if (registerForm.password.value.length &lt; 6) &#123; alert('密码长度不能少于 6 位'); return false; &#125; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123; alert('手机号码格式不正确'); return false; &#125;&#125; 问题: registerForm.onsubmit 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有 的校验规则 registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的校验规则，或者想把密码的长 度校验从 6改成 8，我们都必须深入 registerForm.onsubmit 函数的内部实现，这是违反开 放—封闭原则的。 算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的 校验，那我们很可能将这些校验逻辑复制得漫天遍野 策略模式重构代码基础版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 策略类 * 存储所有的校验规则 */let strategies = &#123; isNonEmpty(value, errMsg) &#123; if (value === '') &#123; return errMsg &#125; &#125;, minLength(value, length, errMsg) &#123; if (value.length &lt; length) &#123; return errMsg &#125; &#125;, isMobile(value, errMsg) &#123; if (!/^1[3|8|7|8][0-9]&#123;9&#125;$/.test(value)) &#123; return errMsg &#125; &#125;&#125;/** * context * 负责接收用户的请求并委托给策略对象。 */class Validator &#123; constructor() &#123; this.cache = [] &#125; add(dom, rule, errMsg) &#123; let ary = rule.split(':') // 数组里面存每一个校验方法，但没有调用 this.cache.push(function() &#123; let strategy = ary.shift() ary.unshift(dom.value) ary.push(errMsg) return strategies[strategy](...ary) &#125;) &#125; /** * 循环调用 cache 里面的方法 */ start() &#123; for(let i = 0, validataFun; validataFun = this.cache[i++];) &#123; var msg = validataFun() if (msg) &#123; return msg &#125; &#125; &#125;&#125;let validataFun = () =&gt; &#123; let validator = new Validator() // 添加校验规则 validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空'); validator.add(registerForm.password, 'minLength:6', '密码长度不能少于 6 位'); validator.add(registerForm.phoneNumber, 'isMobile', '手机号码格式不正确'); // 获取校验结果 let errorMsg = validator.start() return errorMsg&#125;let registerForm = document.getElementById('registerForm')registerForm.onsubmit = () =&gt; &#123; let errMsg = validataFun() // 如果 errMsg 非空，说明没有通过校验 if (errMsg) &#123; alert(errMsg) return false &#125;&#125; 优点： 各个模块功能明确，可以进行抽离封装，实现复用 升级版在上面的例子中，每一个表单一次只能添加一种校验规则，我们期望它可以一次添加多种校验规则 如 1234567validator.add(registerForm.userName, [&#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空'&#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于 10 位'&#125;]); 具体实现 抽离，封装，表单验证模块 ./strategies.js 1234567891011121314151617export default &#123; isNonEmpty(value, errMsg) &#123; if (value === '') &#123; return errMsg &#125; &#125;, minLength(value, length, errMsg) &#123; if (value.length &lt; length) &#123; return errMsg &#125; &#125;, isMobile(value, errMsg) &#123; if (!/^1[3|8|7|8][0-9]&#123;9&#125;$/.test(value)) &#123; return errMsg &#125; &#125;&#125; 注意：如果在 js 中 使用 es6 模块化，需要在 html文件 是 script 标签添加 type=&quot;module&quot;，同时用本地服务器打开项目，否则会跨域 1&lt;script type="module" src="./表单校验策略模式.js"&gt;&lt;/script&gt; 抽离 Validator 类 Validator.js 1234567891011121314151617181920212223242526272829303132333435import strategies from './strategies.js';/** * Validator 类 * 控制校验规则使用 */class Validator &#123; constructor() &#123; this.cache = [] &#125; add(dom, rules) &#123; for (let i = 0, rule; rule = rules[i++];) &#123; let strategyAry = rule.strategy.split(':') let errorMsg = rule.errorMsg this.cache.push(() =&gt; &#123; let strategy = strategyAry.shift() strategyAry.unshift(dom.value) strategyAry.push(errorMsg) return strategies[strategy](...strategyAry) &#125;) &#125; &#125; start() &#123; for (let i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; let errorMsg = validatorFunc() if (errorMsg) &#123; return errorMsg &#125; &#125; &#125;&#125;export default Validator 用户调用代码 1234567891011121314151617181920212223242526272829303132333435import Validator from './Validator.js'/***********************客户调用代码**************************/let registerForm = document.getElementById('registerForm');let validataFunc = function () &#123; let validator = new Validator(); validator.add(registerForm.userName, [&#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于 10 位' &#125;]); validator.add(registerForm.password, [&#123; strategy: 'minLength:6', errorMsg: '密码长度不能小于 6 位' &#125;]); validator.add(registerForm.phoneNumber, [&#123; strategy: 'isMobile', errorMsg: '手机号码格式不正确' &#125;]); let errorMsg = validator.start(); return errorMsg;&#125;registerForm.onsubmit = function () &#123; let errorMsg = validataFunc(); if (errorMsg) &#123; alert(errorMsg); return false; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则三 正则中的括号]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%AD%A3%E5%88%99%E4%B8%89%2F</url>
    <content type="text"><![CDATA[正则表达式括号的作用分组和分支结构这二者是括号最直觉的作用，也是最原始的功能，强调括号内的正则是一个整体，即提供子表达式 分组我们知道 /a+/ 匹配连续出现的 &quot;a&quot;，而要匹配连续出现的 &quot;ab&quot; 时，需要使用 /(ab)+/ 123let regex = /(ab)+/glet string = 'ababa abbbb ababab'console.log(string.match(regex)); // [ 'abab', 'ab', 'ababab' ] 分支结构而在多选分支结构 (p1|p2) 中，此处括号的作用也是不言而喻的，提供了分支表达式的所有可能 比如要匹配如下字符串 I love JavaScript I love Regular Expression 123let reg= /^I love (JavaScript|Regular Expression)$/console.log(reg.test('I love JavaScript'));console.log(reg.test('I love Regular Expression')); 如果去掉正则中的括号，即： 1/^I love JavaScript|Regular Expression$/， 匹配字符串是 “I love JavaScript” 和 “Regular Expression”，当然这不是我们想要的。 分组引用这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作 yyyy-mm-dd 的日期格式，可以写一个简单正则 1let reg = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/ 加括号 1let regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; 括号里面的内容都可以看成不同组 提取数据比如提取出年、月、日，可以这么做 1234let regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; let string = "2017-06-12"; console.log( string.match(regex) );//[ '2019-12-23','2019','12','23',index: 0,input: '2019-12-23',groups: undefined ] match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的 内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match 返回的数组格式是不一样的。 也可以使用正则的 exec 方法 1234let reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/let str = '2019-12-23'console.log(reg.exec(str));// [ '2019-12-23','2019','12','23',index: 0,input: '2019-12-23',groups: undefined ] 同时，也可以使用构造函数的全局属性 $1 至 $9 来获取： 1234567891011let reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/let str = '2019-02-24'// 直接使用正则方法 不用接收返回值reg.test(str) // 或 reg.exec 或 str.match(reg)console.log(RegExp.$1); // 2019console.log(RegExp.$2); // 02console.log(RegExp.$3); // 24 替换比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 1234let reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/,str = '2019-12-24',res = str.replace(reg, '$2/$3/$1')console.log(res); // 12/24/2019 其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式： 123456let reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/,str = '2019-12-24'let res = str.replace(reg, function () &#123; return RegExp.$2 + '/' + RegExp.$3 + '/' + RegExp.$1&#125;)console.log(res); // 12/24/2019 也等价于: 12345678let reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/, str = '2019-12-24', res = str.replace(reg, function (match, year, month, day) &#123; return month + '/' + day + '/' + year &#125;)console.log(res); // 12/24/2019 反向引用 除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。 比如要写一个正则支持匹配如下三种格式： 1232016-06-12 2016/06/12 2016.06.12 最先可能想到的正则是: 12345678910let reg = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/ let str1 = '2019-12-12',str2 = '2019/12/12',str3 = '2019.12.12',str4 = '2016-06/12'console.log(reg.test(str1)); // trueconsole.log( reg.test(str2) ); // trueconsole.log( reg.test(str3) ); // trueconsole.log( reg.test(str4) ); // true ❌ */ 其中 / 和 . 需要转义。虽然匹配了要求的情况，但也匹配 “2016-06/12“ 这样的数据。 要使分隔符前后一直，使用反向引用 123456789let reg = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/let str1 = '2019-12-12', str2 = '2019/12/12', str3 = '2019.12.12', str4 = '2019-12/12'console.log(reg.test(str1)); // trueconsole.log(reg.test(str2)); // trueconsole.log(reg.test(str3)); // trueconsole.log(reg.test(str4)); // false ✔ 注意里面的 \1，表示的引用之前的那个分组 (-|\/|\.)。不管它匹配到什么（比如 -），\1 都匹配那个同 样的具体某个字符 括号嵌套则么办 以左括号为准 12345678let reg = /^((\d)(\d(\d)))\1\2\3\4$/let str = '1231231233'console.log(reg.test(str)); //trueconsole.log(RegExp.$1); // 123console.log(RegExp.$2); // 1console.log(RegExp.$3); // 23console.log(RegExp.$4); // 3 \10 表示什么另外一个疑问可能是，即 \10 是表示第 10 个分组，还是 \1 和 0 呢？ 答案是前者 如果真要匹配 \1 和 0 的话，请使用 (?:\1)0 或者 \1(?:0) 分组后面有量词会怎么样 分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配 123 let reg = /(\d)+ \1/ console.log(reg.test('12345 1')); // falseconsole.log(reg.test('12345 5')); // true 从上面看出，分组 (\d) 引用的数据是 “5”。 非捕获括号如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。 此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3) 如 \10 的例子 练习字符串 trim 方法模拟 trim 方法是去掉字符串的开头和结尾的空白符 方法一：匹配到开头和结尾的空白符，然后替换成空字符 12345String.prototype.Mytrim = function () &#123; let reg = /^\s+|\s+$/g return this.replace(reg, '')&#125;console.log(' sss '.Mytrim()); // sss 方法二：匹配整个字符串，然后用引用来提取出相应的数据： 12345String.prototype.Mytrim = function () &#123; let reg = /^\s*(.*?)\s*$/g return this.replace(reg, '$1')&#125;console.log(' sss '.Mytrim()); //sss 这里使用了惰性匹配 *?，不然也会匹配最后一个空格之前的所有空格的 将每个单词的首字母转换为大写 my name is zhao =&gt; My Name Is Zhao 12345 function titleize(str) &#123; return str.toLowerCase().replace(/(^|\s)[a-z]/g, c =&gt;c.toUpperCase()) &#125;console.log(titleize('my name is zhao')); /(^|\s)\w/g 表示匹配 开头或者空字符后面的第一个小写字母 驼峰化 -good-dog=&gt; GoodDog 或 good-dog =&gt; goodDog 或 good_dog =&gt; goodDog 123let camelize = str =&gt; str.replace(/[-_\s](.)?/g, (match,c) =&gt; c ? c.toUpperCase() : '')console.log(camelize('-moz-transform')); 逆驼峰化12let dasherize = str =&gt; str.replace(/([A-Z])/g, '-$1').replace(/-([A-Z])/g, c =&gt; c.toLowerCase()).replace(/^-/, '')console.log(dasherize('mozTransform')); 检测 html 成对标签匹配匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;， 匹配一个闭标签，可以使用 &lt;\/[^&gt;]+&gt; [^&gt;]: 表示 非&gt; 1let regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/ 其中开标签 &lt;[\^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt;，使用括号的目的是为了后面使用反向引用， 而提供分组。闭标签使用了反向引用，&lt;\/\1&gt; 另外，[\d\D]的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F12%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式什么是单例模式 单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点 实现一个单例模式要实现一个标准的单例模式并不复杂，无非是用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。代码如下 1234567891011121314151617181920212223class Singleton &#123; constructor(name) &#123; this.name = name this.instance = null &#125; getName() &#123; console.log(this.name); &#125; // 静态方法 static getInstance(name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name) &#125; return this.instance &#125;&#125;let a = Singleton.getInstance('zhao1')let b = Singleton.getInstance('zhao2')console.log(a === b);a.getName() // zhao1b.getName() // zhao1 因为 创建a 的 实例对象时 this.instance 保存了创建的实例对象，在创建b 实例对象时 直接返回了 a 的实例对象 我们通过 Singleton.getInstance 来获取 Singleton 类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的“不透明性”，Singleton 类的使用者必须知道这是一个单例类， 跟以往通过 new XXX的方式来获取对象不同，这里偏要使用 Singleton.getInstance 来获取对象。 透明的单例模式1234567891011121314151617181920212223242526let CreateDiv = (function () &#123; let instance class CreateDiv &#123; constructor(html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125; init() &#123; let div = document.createElement('div'); div.innerHTML = this.html; document.body.append(div); &#125; &#125; return CreateDiv &#125;)() // 可以用 new 直接创建实例对象， let a = new CreateDiv('sven1'); let b = new CreateDiv('sven2'); alert(a === b) //true 为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的 Singleton 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服 用代理实现单例模式12345678910111213141516171819202122232425262728293031323334let CreateDiv = (function () &#123; class CreateDiv &#123; constructor(html) &#123; this.html = html; this.init(); &#125; init() &#123; let div = document.createElement('div'); div.innerHTML = this.html; document.body.append(div); &#125; &#125; return CreateDiv &#125;)() let proxySingletonCreateDiv = (function () &#123; let instance return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html) &#125; return instance &#125; &#125;)() // 使用代理模式的单例模式创建实例 let a = new proxySingletonCreateDiv('sven1'); let b = new proxySingletonCreateDiv('sven2'); // 普通的创建实例 let c = new CreateDiv('zhao') let d = new CreateDiv('zhang') alert(a === b) // true 通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。这样一来，CreateDiv 就变成了 一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果 JavaScript中的单例模式在 JavaScript 中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什 么要为它先创建一个“类”呢？这无异于穿棉衣洗澡，传统的单例模式实现在 JavaScript 中并 不适用。 单例模式的核心是确保只有一个实例，并提供全局访问 全局变量不是单例模式，但在 JavaScript开发中，我们经常会把全局变量当成单例来使用。例如： 1var a = &#123;&#125;; 当用这种方式创建对象 a时，对象 a确实是独一无二的。如果 a变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样就 满足了单例模式的两个条件 降低全局变量的污染作为普通的开发者，我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染 使用命名空间12345678var namespace1 = &#123; a()&#123; alert (1); &#125;, b()&#123; alert (2); &#125;&#125;; 把 a和 b都定义为 namespace1 的属性，这样可以减少变量和全局作用域打交道的机会 使用闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信 1234567891011let user = (function () &#123; let _name = 'zhao', _age = 21 return &#123; getinfo() &#123; return `$&#123;_name&#125;+$&#123;_age&#125;` &#125; &#125;&#125;)()console.log(user.getinfo()); 我们用下划线来约定私有变量name 和age，它们被封装在闭包产生的作用域中，外部是访问不到这两 惰性单例惰性单例指的是在需要的时候才创建对象实例 如点击登陆按钮，显示登陆弹窗， 方法一：页面加载的时候就创建dom节点，然后隐藏，直到点击登陆时显示 因为登录浮窗总是一开始就被创建好，那么很有可能将白白浪费一些DOM节点 方法二：点击登陆时动态创建节点，并用一个变量保存是否已经创建过登陆浮窗 123456789101112131415161718192021222324&lt;html&gt;&lt;body&gt; &lt;button id="loginBtn"&gt;登录&lt;/button&gt;&lt;/body&gt;&lt;script&gt; let createLoginLayer = (function () &#123; let div; return function () &#123; if (!div) &#123; div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125; &#125;)(); document.getElementById('loginBtn').onclick = function () &#123; let loginLayer = createLoginLayer(); loginLayer.style.display = 'block'; &#125;;&lt;/script&gt;&lt;/html&gt; 在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能， 看起来是一件挺奇妙的事情]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则二 匹配位置]]></title>
    <url>%2F2019%2F12%2F20%2F%E6%AD%A3%E5%88%99%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[正则二^ 和 $^（脱字符）匹配开头，在多行匹配中匹配行开头。 $（美元符号）匹配结尾，在多行匹配中匹配行结尾。 1234567891011let result = "hello".replace(/^|$/g, '#'); console.log(result); // =&gt; "#hello#"// 多行匹配let result = "I\nlove\njavascript".replace(/^|$/gm, '#'); console.log(result);/*#I##love##javascript#*/ 多行匹配模式（即有修饰符 m）时 \b 和 \B\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。 12let str = "[JS] Lesson_01.mp4".replace(/\b/g, '#')console.log(str); // [#JS#] #Lesson_01#.#mp4# \B B 就是 \b 的反面的意思，非单词边界 12var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#'); console.log(result);// =&gt; "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4" 环视 环视只进行子表达式的匹配，不占有字符，匹配到的内容不保存到最终的匹配结果，是零宽度的。环视匹配的最终结果就是一个位置。 环视的作用相当于对所在位置加了一个附加条件，只有满足这个条件，环视子表达式才能匹配成功 环视按照方向划分有顺序和逆序两种，按照是否匹配有肯定和否定两种，组合起来就有四种环视。 顺序环视相当于在当前位置右侧附加一个条件， 而逆序环视相当于在当前位置左侧附加一个条件。 表达式 说明 (?&lt;=Expression) 逆序肯定环视，表示所在位置左侧能够匹配Expression (?&lt;!Expression) 逆序否定环视，表示所在位置左侧不能匹配Expression (?=Expression) 顺序肯定环视，表示所在位置右侧能够匹配Expression (?!Expression) 顺序否定环视，表示所在位置右侧不能匹配Expression 详解(?=Expression)Expression 是一个子模式，即 Expression 前面的位置，或者说，该位置后面的字符要匹配 p 1234 let str = 'hello' let str2 = 'helo'console.log(str.replace(/(?=ll)/g, '$')); // he$lloconsole.log(str2.replace(/(?=ll)/g, '$')); // helo (?!Expression)匹配 (?=Expression) 没有匹配的位置 123let str = 'hello'console.log(str.replace(/(?=ll)/g, '$')); // he$lloconsole.log(str.replace(/(?!ll)/g, '$')); // $h$el$l$o$ 逆序环视同理 练习数字的千位分隔符表示法 比如把 “12345678”，变成 “12,345,678”。 弄出最后一个逗号 12let str = '12345678'console.log(str.replace(/(?=\d&#123;3&#125;$)/g, ',')); //12345,678 (?=\d{3}$) 匹配 \d{3}$ 前面的位置。而 \d{3}$ 匹配的是目标字符串最后那 3 位数字。 弄出所有的逗号 因为逗号出现的位置，要求后面 3 个数字一组，也就是 \d{3} 至少出现一次。 此时可以使用量词 + 12let str = '12345678'console.log(str.replace(/(?=(\d&#123;3&#125;)+$)/g, ',')); // 12,345,678 多次​测试​发现:warning: 12let str2 = '123456789'console.log(str2.replace(/(?=(\d&#123;3&#125;)+$)/g, ',')); // ,123,456,789 解决开头会被替换成 ， 我们知道匹配开头可以使用 ^，但要求这个位置不是开头怎么办 用(?!^) 12let str2 = '123456789'console.log(str2.replace(/(?!^)(?=(\d&#123;3&#125;)+$)/g, ',')); // 123,456,789 密码校验 密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。 只匹配6-12为字符 1let reg = /^[0-9a-zA-Z]&#123;6,12&#125;$/ 必须包含数字 1let regex = /(?=.*[0-9])^[0-9A-Za-z]&#123;6,12&#125;$/; 解释： (?=.*[0-9])^ 表示开头前面还有个位置（当然也是开头，即同一个位置） (?=.*[0-9]) 表示该位置后面的字符匹配 .*[0-9]，即，有任何多个任意字符，后面再跟个数字。 翻译成大白话，就是接下来的字符，必须包含个数字。 多种匹配 12345let reg = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9a-zA-Z]&#123;6,12&#125;$/console.log(reg.test('1234a')); // falseconsole.log(reg.test('123456')); // falseconsole.log(reg.test('12345a')); // true 解法二： 至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写 字母。 不能全是数字 1let regex = /(?!^[0-9]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/; 三种都不能 1let regex = /(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/;]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则一 基础]]></title>
    <url>%2F2019%2F12%2F19%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%2F</url>
    <content type="text"><![CDATA[正则表达式一什么是正则表达式正则表达式是匹配模式，要么匹配字符，要么匹配位置 两种模糊匹配横向模糊匹配横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的 其实现的方式是使用量词。譬如 {m,n}，表示连续出现最少 m 次，最多 n 次 纵向模糊匹配纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种 可能。 其实现的方式是使用字符组。譬如 [abc]，表示该字符是可以字符 “a”、”b”、”c” 中的任何一个 [^abc]，表示是一个除 “a”、”b”、”c”之外的任意一个字 符。字符组的第一位放 ^（脱字符），表示求反的概念。 字符组需要强调的是，虽叫字符组（字符类），但只是其中一个字符 eg: [abc]表示该字符是可以字符 “a”、”b”、”c” 中的任何一个 范围表示法[1-9]: 匹配1 到 9 中的某一个数字 [a-z]: 匹配 a 到 z 中的某一个字母 [A-Z]: 匹配 A 到 Z 中的某一个字母 因为连字符有特殊用途，要匹配 “a”、”-“、”z” 这三者中任意一个字符可以使用 [-az]或[az-]或[a\-z] 简写 字符组 具体含义 \d [0-9]。表示是一位数字。 记忆方式：其英文是 digit（数字） \D 表示 [^0-9]。表示除数字外的任意字符。 \w 表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。 记忆方式：w 是 word 的简写，也称单词字符 \W 表示 [^0-9a-zA-Z_]。非单词字符 \s 表示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页 符。 记忆方式：s 是 space 的首字母，空白符的单词是 white space。 \S 表示 [^ \t\v\n\r\f]。 非空白符 . 表示 [^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外。 记忆方式：想想省略号 … 中的每个点，都可以理解成占位符，表示任何类似的东 如果要匹配任意字符怎么办？可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。 量词 量词 具体含义 {m,} 表示至少出现 m 次。 {m} 等价于 {m,m}，表示出现 m 次。 ? 等价于 {0,1}，表示出现或者不出现。 记忆方式：问号的意思表示，有吗？ + 等价于 {1,}，表示出现至少一次。 记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。 * 等价于 {0,}，表示出现任意次，有可能不出现。 记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 贪婪匹配和懒惰匹配通过在量词后面加个问号就能实现懒惰匹配 贪婪匹配/\d{2,5}/，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字，只要在能力范围内，越多越好 懒惰匹配/\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了 12345let string = '123 1234 12345 1'// 贪婪匹配console.log(string.match(/\d+/g)); // [ '123', '1234', '12345', '1' ]// 懒惰匹配console.log(string.match(/\d&#123;2,5&#125;?/g)); // [ '12', '12', '34', '12', '34' ] 多选分支一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一 具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一 123var regex = /good|nice/g; var string = "good idea, nice try.";console.log( string.match(regex) ); // =&gt; ["good", "nice"] 注意： 分支结构是懒惰匹配，当前面匹配上了，后面将不会匹配 练习匹配 16 进制的颜色1234567let regex = /#([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)/glet regex2 = /#([a-fA-F0-9]&#123;3&#125;|[a-fA-F0-9]&#123;6&#125;)/glet string = "#ffbbad #Fc01DF #FFF #ffE fff #ffz #ffff";console.log(string.match(regex)); // [ '#ffbbad', '#Fc01DF', '#FFF', '#ffE', '#fff' ]console.log(string.match(regex2)); // [ '#ffb', '#Fc0', '#FFF', '#ffE', '#fff' ] 用 regex2 匹配时 由于多选分支是 懒惰匹配 所以返回只返回了匹配到的三位 匹配时间匹配格式为： 24: 30 05: 59 7:09 7:9 1234567let reg = /^(0?[0-9]|[1][0-9]|2[0-3]):(0?[0-9]|[1-5][0-9])$/console.log(reg.test('23:59')); // trueconsole.log(reg.test('05:30')); // trueconsole.log(reg.test('5:30')); // trueconsole.log(reg.test('5:3')); // trueconsole.log(reg.test('24:30')); // false 匹配日期日期格式为 yyyy-mm-dd 1234let regex = /^\d&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/console.log(regex.test('2012-02-01')); // trueconsole.log(regex.test('2012-21-01')); // false 匹配id从 1&lt;div id="container" class="main"&gt;&lt;/div&gt; 提取出 id=”container” 12345let string = '&lt;div id="container" class="main"&gt;&lt;/div&gt;'let regex = /id=".*"/let regex2 = /id=".*?"/console.log(string.match(regex)[0]); // id="container" class="main"console.log(string.match(regex2)[0]); // id="container" 因为 . 是通配符，本身就匹配双引号的，而量词 * 又是贪婪的，当遇到 container 后面双引号时，是不会 停下来，会一直继续匹配 所以此处应该使用 懒惰模式 进行匹配]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2019%2F12%2F18%2F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[高阶函数什么是高阶函数高阶函数是指至少满足下列条件之一的函数 函数可以作为参数被传递 函数可以作为返回值输出 函数可以作为参数被传递 把函数当作参数传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就 是常见的回调函数 1234567891011let getData = function(id, callback) &#123; $.ajax('aaa/bbb/ccc?' + id, function(data) &#123; // 调用回调函数处理业务逻辑 callback &amp;&amp; callback(data) &#125;)&#125;// 调用 getData 方法，传入回调函数处理逻辑业务getData(123, function (data) &#123; console.log(data.name)&#125;) 同时数组的 sort，map，some，every 等都是常见的高阶函数 函数可以作为返回值输出 相比把函数当作参数传递，函数当作返回值输出的应用场景也许更多，也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数，意味着运算过程是可延续的 在判断一个数据的具体类型的时候可以使用 Object.prototype.toString来判断，数组返回 [object Array]”，字符串返回 “[object String]”，数字返回 ‘[object Number]’，因此可以写出 123456789let isString = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object String]';&#125;;let isArray = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]';&#125;;let isNumber = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object Number]';&#125;; 高阶函数优化 1234567891011let isType = (type) =&gt; &#123; return (obj) =&gt; &#123; return Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]` &#125;&#125;let isArray = isType('Array')let isString = isType('String')console.log(isArray([])); // trueconsole.log(isString('aa')); // true 高阶函数的应用柯里化（currying） currying 又称部分求值。一个 currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保 存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值 求和 12345678910111213141516171819202122232425262728293031let curring = function(fn) &#123; // 存放传入的数字 let args = [] return function inner(...parse) &#123; // 如果没有传入参数则返回求和函数 fn 的调用 if (parse.length === 0) &#123; return fn.apply(this, args) &#125; else &#123; // args 里面追加传入的数字 [].push.apply(args, parse) // 返回 inner 方法，方便连续调用 return inner &#125; &#125;&#125;// 求和函数let cost = (function () &#123; let money = 0 return function (...params) &#123; for(let i = 0, l = params.length; i &lt; l; i++) &#123; money += params[i] &#125; return money &#125;&#125;)()let res = curring(cost)res(100)(200)(300)res(20)console.log(res()); // 620 节流函数1234567891011121314151617181920212223242526272829let throttle = function (fn, interval) &#123; let _self = fn, timer, firstTime = true return function () &#123; let args = arguments, _me = this if (firstTime) &#123; _self.apply(_me, args) return firstTime = false &#125; if (timer) &#123; return false &#125; timer = setTimeout(() =&gt; &#123; clearTimeout(timer) timer = null _self.apply(_me, args) &#125;, interval || 500); &#125;&#125;window.onresize = throttle(function () &#123; console.log();&#125;, 500)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个bind方法]]></title>
    <url>%2F2019%2F12%2F17%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[借用构造函数实现一个 bind方法bind 方法的作用返回一个 修改了 this 指向的 函数 代码123456789101112131415161718192021222324Function.prototype.Mybind = function () &#123; // 1 var self = this, // 2 // context: 上下文对象(obj对象) context = [].shift.call(arguments), // args: Mybind 传入的参数(1, 2) args = [].slice.call(arguments); // 3 return function () &#123; // 4 return self.apply(context, [].concat.call(args, [].slice.call(arguments))); &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function (a, b, c, d) &#123; alert(this.name); alert([a, b, c, d])&#125;.Mybind(obj, 1, 2); func(3, 4); 解析 再使用 Mybind 方法的时候，this 指的是当前使用 Mybind 的函数对象， 此处相当于复制了一份函数对象 借用构造函数 Array.shift() 如果不传入参数，默认移除并返回第一个元素,因为 arguments 是一个类数组，没有shift方法，所以用 call 借用了Array的shift方法 Array.slice (start，end) 返回的是一个截取后的数组，如果不传参数则返回整个数组 这里同样借用了 Array的slice方法，将一个类数组转换成数组 返回值是一个函数 这个函数返回了一个使用 Mybind 的那个函数(func 的复制)的调用，并修改了 this 为传入的上下问对象(obj) es6 重写 bind 方法123456789101112131415161718192021Function.prototype.Mybind = function (...arg) &#123; let self = this, context = arg.shift() return function () &#123; return self.apply(context, arg) &#125;&#125;let obj2 = &#123; name: 'sven'&#125;let func2 = function (...args) &#123; console.log(this.name); console.log(args);&#125;let res = func2.Mybind(obj2, 1, 2)res()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秦始皇帝陵博物院项目总结]]></title>
    <url>%2F2019%2F10%2F26%2F%E5%85%B5%E9%A9%AC%E4%BF%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[秦始皇帝陵博物院项目总结这周秦始皇帝陵博物院项目已经进入尾声，所以今天抽空将自己在这个项目中的感悟与收获进行自我总结 项目开发总结 项目整体设计与搭建 技术难点及克服方法 团队合作感悟 交流 互助 合作 在项目中的失误、不足及改进方法 没有意识到原型图的重要 对项目的难度以及开发时间估计有偏差 与团队成员沟通不足 过于依赖外部而忽略了自己的能力 项目开发总结项目整体设计与搭建项目设计 ​ 作为一个前端工程师，要开发一个项目，首先要了解这个项目是干什么的，要知道这个项目有那些部分，每一部分有那些功能，一定要在了解完这些后在动手开发这个项目。 ​ 作为一个脱离了脚手架与各种组件，只能用原生 html 与 js 开发的项目，我遇到的第一个问题就是如何去设计这个项目，需要在项目文件下建立那些文件夹、每个文件夹下面应该存放什么内容、如果后续需要添加新的东西应该存放在什么地方、如何保证项目文件目录结构清晰，方便自己的开发和维护，这些都需要一个开发者自顶向下的思考。 ​ 通过对整个项目的分析，以及和同事的分析后得出的项目设计方法就是先对项目按照大模块划分，在对模块按照文件类型进行划分。按照这个思路，我将整个秦始皇帝陵博物院项目分成了 公共模块，政务模块，采购平台模块，以及入口模块，以及公共资源common 模块，又将每个模块划分成 页面文件，图片文件，css 文件，js 文件 ，以及这个模块公用的文件。就这样对项目进行拆分，完成了项目结构的搭建。 技术难点及克服方法网页适配问题资源共用问题插件使用问题其他问题团队合作感悟交流互助合作在项目中的失误、不足及改进方法没有将静态图片资源和动态图片资源分离没有建立一个公用的js 文件来封装公共方法没有意识到原型图的重要对项目的难度以及开发时间估计有偏差与团队成员沟通不足过于依赖外部而忽略了自己的能力]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git踩坑]]></title>
    <url>%2F2019%2F10%2F11%2Fgit%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[git 删除分支问题删除命令删除本地分支 普通删除（不能删除没有合并的分支） 1git branch --delete &lt;分支名&gt; 强制删除（可以删除没有合并分支） 1git branch -D &lt;分支名&gt; 删除远程分支1git push orinin --delete &lt;分支名&gt; 解决本地分支和远程分支不同步问题 远程分支已经删除，但是在本地依然显示 查看本地所有分支1git branch -a 显示结果中白色是为本地分支，红色为远程分支 查看远程分支和本地分支的对应关系 1git remote show origin 在对应关系中有的后面会显示 (use ‘git remote prune’ to remove)说明此分支远程已经移除 ，而本地依然存在 将本地分支和远程分支同步 1git remote prune origin]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向数据绑定原理]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue 中双向数据绑定的原理利用 Object.defineProperty() 方法实现双向数据绑定 Object.defineProperty(obj, prop, descriptor)方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象 obj ：要在其上定义属性的对象。 prop：要定义或修改的属性的名称 descriptor：将被定义或修改的属性描述符。 descriptor 为一个对象，有两个方法get 和 set 当 获取 对象上的属性时触发 get方法 添加对象属性时 触发 set 方法 123456789101112131415161718192021222324&lt;body&gt; &lt;input type="text" id="userName"&gt;&lt;br&gt; &lt;span id="uName"&gt;&lt;/span&gt; &lt;script&gt; let obj = &#123; pwd: 123456 &#125; Object.defineProperty(obj, 'userName', &#123; get()&#123; console.log("get init") &#125;, // vul 为添加属性的值 set(val) &#123; console.log('set init'); document.querySelector('#uName').innerHTML = val document.querySelector('#userName').value = val &#125; &#125;) document.querySelector('#userName').addEventListener('keyup', (event) =&gt; &#123; obj.userName = event.target.value &#125;) &lt;/script&gt;&lt;/body&gt; 分析 : 当键盘按下时，修改 obj 对象的 userName 属性， 触发 set 事件 给 文本框添加innerHtml，实现 页面的改变影响 js 内存的改变 当 浏览器控制台 修改obj.userName 时， 会改变文本框的 innerHTML和 span 的 value ，实现 js 内存属性的改变，影响页面的变化]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包总结]]></title>
    <url>%2F2019%2F09%2F08%2F%E9%97%AD%E5%8C%85%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[闭包函数的创建和执行过程函数的创建 开辟一个堆内存 把函数体中的代码当作字符串存储进去 把堆内存的地址赋值给函数名 函数在那创建，那么它执行的时候所需要查找的上级作用域就是谁 函数的执行 形成一个私有的作用域（执行上下文，私用的栈内存） 执行一次，产生一个，互不影响 参数赋值 &amp; 变量提升 代码执行 把堆内存中的字符串代码一行行执行 作用域链查找 遇到一个变量，先判断是否为私有变量（函数中声明的变量和形参是私有变量）如果是直接操作，不是向上级作用域查找，直到 window 私有变量和外界的变量没有必然关系，可以理解成被私有的栈内存保护 这就是闭包的保护级制 堆栈内存的释放问题 函数执行就会形成栈内存（在内存中分配空间），如果不及时销毁，会导致内存爆满也就是内存泄漏 堆内存的释放创建一个引用类型，就会形成一个堆内存，如果当前的堆内存不被引用，就会被浏览器给释放 12let obj = &#123;name: zhao&#125;let oop = obj 此时对象被 obj 和 oop 变量引用，所以不能释放 12obj = nulloop = null 此时 对象 不被引用，所以就会被释放 栈内存释放栈内存的形成方式 浏览器形成的全局作用域 执行时函数形成的私有作用域 let / const 形成的代码块 栈内存销毁方式 全局栈内存 关闭页面 函数私有栈内存 一般情况函数执行完，浏览器自动清除 一旦栈内存中的某个东西（一般是堆内存）被私有作用域以外的事物引用，则栈内存不能立即被销毁，私有作用域中的变量等信息得以保存，只有外部引用解除，才能被销毁 1234567function X() &#123; return function() &#123;...&#125;&#125; let f = X() // 此时 f 引用 X 中返回的函数，所以 X 在执行完不能释放 f = null //此时才可以 闭包 解释一： 函数形成的私用作用域就是闭包 解释二： 函数中的堆内存被私有作用域以外的变量引用，形成闭包 123456789101112let i = 5function fn(i) &#123; return function (n) &#123; console.log(n + (++i)) &#125;&#125;let f = fn(1)f(2) // 4fn(3)(4) // 8fn(5)(6) // 12f(7) // 10console.log(i) // 5 解释： 1let f = fn(1) 首先在栈内存中执行 fn 函数 返回 里面函数的栈内存地址，并将其赋值给 变量 f ，此时由于 变量 f 引用了栈内存中 fn 返回的 堆内存地址，此时的 fn 执行的 栈内存不销毁，同时变量 i 被保存。私有变量 i 此时是 1 1f(2) 调用 fn 返回的函数并传参 2 ，返回 结果为 2 + (++i) = 4 , 私有变量 i 同时变为 2 ，这时 返回的函数执行完毕，销毁，但是 fn 不销毁,变量 i也不销毁 1fn(3)(4) 再次执行 fn 则需要重新 开辟一个栈内存，先执行 fn(3)，再执行返回的函数，由于再这个栈内存中，没有什么引用 返回函数的堆地址，所以返回函数执行完后 fn() 和 返回函数都销毁 1fn(5)(6) 原理同上 1f(7) 此时 fn 函数 在栈中没有销毁，则返回的 为 7 + (++i) = 10; 变量 i 变为值 为 3 经典用法一12345678910111213141516171819&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; var nodes = document.getElementsByTagName('div'); for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; nodes[i].onclick = function () &#123; alert(i); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i的值已经是 5，所以在 div 的 onclick事件函数中顺着作用域链从内到外查找变量 i时，查找到的值总是 5。 用闭包封存 i 123456789var nodes = document.getElementsByTagName('div');for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; (function (i) &#123; nodes[i].onclick = function () &#123; alert(i); &#125; &#125;)(i)&#125;; 闭包的作用一、封装变量二、延长局部变量的生命 闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量” eg： 累乘方法的优化 最基本方法 123456789let mult = function (...args) &#123; let a = 1 for(let i = 0, l = args.length; i &lt; l; i++) &#123; a = a* args[i] &#125; return a&#125;console.log(mult(1,2,3)); 对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能 缓存优化 1234567891011121314151617let cache = &#123;&#125;let mult = function (...args) &#123; let args2 = args.join(',') if (cache[args2]) &#123; return cache[args2] &#125; let a = 1 for (let i = 0, l = args.length; i&lt; l; i++) &#123; a = a * args[i] &#125; return cache[args2] = a&#125;console.log(mult(1, 2, 3, 5, 6, 7)); // 执行方法获取数据console.log(mult(1, 2, 3, 5, 6, 7)); // 直接在缓存中获取数据 我们看到 cache 这个变量仅仅在 mult函数中被使用，与其让 cache变量跟 mult函数一起平行地暴露在全局作用域下，不如把它封闭在 mult 函数内部，这样可以减少页面中的全局变量，以 避免这个变量在其他地方被不小心修改而引发错误 闭包优化 1234567891011121314151617let mult = (function () &#123; let cache = &#123;&#125; return function (...args) &#123; let args2 = args.join(',') if (cache[args2]) &#123; return cache[args2] &#125; let a = 1 for (let i = 0, l = args.length; i&lt;l; i++) &#123; a = a * args[i] &#125; return cache[args2] = a &#125;&#125;)()console.log(mult(1, 2, 3, 5, 6, 7)); 进一步封装 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些 小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他 地方使用，最好是把它们用闭包封闭起 12345678910111213141516171819let mult = (() =&gt; &#123; let cache = &#123;&#125; let calculate = (...args) =&gt; &#123; let a = 1 for (let i = 0, l = args.length; i &lt; l; i++) &#123; a = a * args[i] &#125; return a &#125; return (...args) =&gt; &#123; let args2 = args.join(',') if (args in cache) &#123; return cache[args2] &#125; return cache[args2] = calculate(...args) &#125;&#125;)()console.log(mult(1, 2, 3, 5, 6, 7));]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mockjs]]></title>
    <url>%2F2019%2F09%2F04%2FMockjs%2F</url>
    <content type="text"><![CDATA[Mockjs用于前端自己造加数据的库 文档:https://github.com/nuysoft/Mock/wiki 上车安装1npm i Mockjs -D vue 中使用 在 vue的 src 目录下面 新建一个 mock 文件夹，里面新建一个 index.js文件 在 index.js 文件下面导入 mockjs 包 1import Mock from 'mockjs' 将 index.js 导入到 main.js 1import './mock/' 用 mockjs 模拟 api 拦截 get 和 post 请求 用 Mock.mock() 模拟 api 接口 参数一： 接口地址(可以写成正则)，可选参数 参数二： 请求方式， 可选参数 参数三： 返回数据或者函数 拦截 get 请求12345678Mock.mock('aaa/bbb', 'get', &#123; status: 0, msg: 'ok', data: &#123; name: 'zhaozhaozhao', age: 22 &#125;&#125;) 拦截 post 请求1234567Mock.mock('/api/addgoods', 'post', function (options) &#123; console.log(options) return &#123; status: 0, msg: 'ok' &#125;&#125;) 函数的 option 参数为 提交的数据 用 mockjs 创造假数据文档写的很详细，不想重复累赘了 这部分还是看官网吧，又不难 本来不想写了，但是由于项目后端的接口跨域问题迟迟解决不了，耽误了我的进度，于是决定自己动手造数据，所以我又回来了😂、 原生 js 项目中使用mockjs在 html 文件中 引入 mockjs 文件 ， 当后台的接口可以调通只需要删除mockjs 的引用即可 1234// 这个是mock.js 文件 &lt;script src="./../../lib/Mock-refactoring/dist/mock.js"&gt;&lt;/script&gt;// 这个文件是自己建立的用来配置mockjs 拦截和返回结果规则的文件&lt;script src="./../../myMock.js"&gt;&lt;/script&gt; 在myMock.js 中写规则 12345678910111213141516Mock.mock(/bmy/, 'get', function (options) &#123; return Mock.mock(&#123; 'page': &#123; showCount: 15, "totalPage": 100/2, "currentPage": 2, &#125;, 'list|15': [&#123; // 返回15条数据 "publishtime": Mock.Random.date(), //随机一个fmtDate 格式的日趋 "title": '@cword(5,10)', // 随机5-10 个汉字 "picture": '@dataImage("200x200")', // 随机一张200x200 的base64的图片 "htmlpath": '@url()' //随机一个url &#125;], &#125;)&#125;) 注意: Mock.random 相当于 @，不过用@需要用&#39;&#39; 包裹起开 如： 123"publishtime": Mock.Random.date()// 等价于"publishtime": ‘@date()’]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mockjs</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥Angular]]></title>
    <url>%2F2019%2F08%2F23%2FAngular%2F</url>
    <content type="text"><![CDATA[angular上车安装 脚手架 1npm i -g @angular/cli 创建项目 1ng new 项目名 启动 –open 设置自动启动浏览器 1ng serve --open 生成目录结构分析src目录 src:│ favicon.ico│ index.html│ main.ts│ polyfills.ts│ styles.less│ test.ts│├─app│ │ app-routing.module.ts // Angular 的路由模块│ │ app.component.html // Angular 的根html│ │ app.component.less // Angular 的根less│ │ app.component.spec.ts // 测试文件│ │ app.component.ts // 这是 Angular 的根组件模块│ │ app.module.ts // 这是 Angular 的 跟模块，配置了 Angular 加载什么应用│ ││ └─components // 自己创建的组件目录│ └─head // 自己创建的组件│ head.component.html│ head.component.less│ head.component.spec.ts│ head.component.ts│├─assets│ .gitkeep│└─environments environment.prod.ts environment.ts 简单使用创建组件在src 目录下面创建一个 components 文件夹 放入 head 组件 1ng g component components/head 使用这个命令会 自动 生成一个 head 组件的文件夹，里面由有四个文件分别是 head.component.html head.component.less head.component.spec.ts head.component.ts 这个文件了面配置了组件名称 同时还会在 app.module.ts 文件中 引入 和 使用 这个组件 使用组件在 Angular 的 html 文件中直接用&lt;组件名&gt;&lt;/组件名&gt; 使用组件 123456&lt;div class="" style = "text-align: center"&gt; hello Angular &lt;!-- 使用组件 --&gt; &lt;app-head&gt;&lt;/app-head&gt;&lt;/div&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; angular 和 vue 指令的对比 vue angular v-bind:title=’aaa’ [title]=’aaa’ v-html=’x’ [innerHTML]=’x’ v-for=”item in GoodsList” *ngFor=”let item of GoodsList” v-if *ngIf :class = ‘{‘name’: true}’ [ngClass] =’{‘name’: true}’ @click= ‘fn’ (click) = ‘fn()’ anuglar 的双向数据绑定 在 app.module.st 文件中引入 1import &#123;FormsModule&#125; from '@angular/forms'; 然后将其添加到 imports中 12345imports: [ // 配置当前模块运行依赖的其他模块 BrowserModule, AppRoutingModule, FormsModule ], 在使用的时候用[(ngModel)]=”input”来进行双向数据绑定 1&lt;input type="text" [(ngModel)]="input"&gt; angular 中的服务在服务中可以存储一些全局的方法或者属性，其他组建可以调用这些方法或者属性 创建服务1ng g service (位置: services/storage) 在服务中添加公共方法 123456789101112131415161718import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root'&#125;)export class StorageService &#123; constructor() &#123; &#125; setStorage(key: string, value: any) &#123; localStorage.setItem(key, JSON.stringify(value)); &#125; getStorage(key: string) &#123; return JSON.parse(localStorage.getItem(key)); &#125; reomveStorage(key: string) &#123; localStorage.removeItem(key); &#125;&#125; 在 app.module.ts 中引入及挂载1import &#123; StorageService &#125; from './services/storage.service'; 挂载 1providers: [StorageService], 在其他组建中使用在组建中引入 1import &#123; StorageService &#125; from '../../services/storage.service'; 在组建中使用 12345678910111213constructor(public service: StorageService) &#123; &#125;// 使用 addList(e: any) &#123; if (e.keyCode === 13) &#123; this.list.unshift(&#123; title: this.thing, status: false, &#125;); this.service.setStorage('userHistory', this.list); this.thing = ''; &#125; &#125; angular 中的 Dom 操作 以及 ViewChildangular 中 通过原生 js(ts) 操作 Dom在组建中使用 ngAfterViewInit生命周期函数，在函数中直接使用js操作Dom 123456ngAfterViewInit(): void &#123; const box1: any = document.querySelector('#box1'); box1.style.color = 'red'; const box2: any = document.querySelector('.box2'); box2.style.color = 'hotpink'; &#125; ngAfterViewInit 函数 指的是dom加载完成后的 生命周期函数 ngAfterViewInit 函数需要 实现于 AfterViewInit 接口，所以需要修改 1234import &#123; Component, OnInit, AfterViewInit &#125; from '@angular/core'export class DomComponent implements OnInit, AfterViewInit 用 ViewChild 获取 dom 节点定义html 节点 用 #xxx 为标记 123&lt;div #box3&gt; this is box3&lt;/div&gt; 使用 ViewChild 12345678 @ViewChild('box3', &#123; static: false &#125;) box3(随便的名字): ElementRef; constructor() &#123; &#125;// 使用ngAfterViewInit(): void &#123; this.box3.nativeElement.style.color = 'blue'; &#125; 用 ViewChild 获取子组件的属性和方法使用子组件 12345// 在父组件中使用子组件&lt;app-head #head&gt;&lt;/app-head&gt;// 父组件的 button&lt;button mat-button (click)="getChildFn()"&gt;获取子组件的方法&lt;/button&gt; ViewChild 获取子组件 123456// 注入@ViewChild('head', &#123;static: true&#125;) head: any;// 使用 getChildFn() &#123; this.head.print(); &#125; 这样就可以调用 子组件上的 print（） 方法 angular 中的父子组建，及组建间通信父传子父组件不仅可以给子组件传递简单的数据，也可以把自己的方法以及整个父组件传递给子组件 1. 父组件调用子组件的时候传入数据 1&lt;app-son [msg] = '传入的数据'&gt;&lt;/app-son&gt; 2. 子组件引入 Input 模块 1import &#123;Component, OnInit, Input&#125; from '@anuglar/core' 3. 子组件中用 @Inpit 接收父组件传递过来的数据 12345export class HeaderComponent inplements OnInint &#123; // 接收 父组件传入的值 @Input() msg: string &#125; 父组件分别向子组件传入数据，函数，和整个父组件的方法 12345678// 传入普通数据&lt;app-son [msg] = '传入的数据'&gt;&lt;/app-son&gt;// 传入一个函数&lt;app-son [run] = "这是父组件的一个函数"&gt;&lt;/app-son&gt;// 传入整个父组件&lt;app-son [father] = "this"&gt;&lt;/app-son&gt; 子传父用 ViewChild 获取子组件的数据 或 方法使用方法见上面的 用 ViewChild 获取子组件的属性和方法 子组件通过 @Output 触发父组件的方法（和vue的子传父有点像） 子组件引入 Output 和 EventEmitter 1import &#123; Component, OnInit, Output, EventEmitter &#125; from '@angular/core'; 子组件实例化EventEmitter 1@Output() private outer = new EventEmitter&lt;string&gt;(); 子组件通过 EventEmitter 对象 outer 实例广播对象 123sendParent() &#123; this.outer.emit('子组件的消息')&#125; 父组件调用子组件的时候，定义接收事件 ，outer 就是子组件的 EventEmitter 对象 outer 1&lt;app-son (outer) = "runParent($event)"&gt;&lt;/app-son&gt; 父组件接收到数据会调用自己的 runParent 方法，获取数据 123runParent(msg: string) &#123; alert(msg)&#125; 非父子组件传递 service（服务） localStorage]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typeScript]]></title>
    <url>%2F2019%2F08%2F21%2FtypeScript%2F</url>
    <content type="text"><![CDATA[typescript上车安装 typescript 1cnpm i -g typescript 将 1.ts 文件编译成 js 1tsc 1.ts vscode 配置ts自动编译成js文件目录 cmd 运行 1tsc --init 这一步会生成一个tsconfig.json 文件 修改 tsconfig.json 的 &quot;outDir&quot;: &quot;./js&quot;,(14行) 此处配置编译后的js 目录 在vscode 中 点击菜单栏的终端 &gt; 运行任务 &gt; tsc: watch –tscconfig.json 类型typescript 常见类型有 number ，string， Boolean，any，number[]（整型数组） 联合类型 （number | string）等等 元组类型 ： 一种特殊的数组类型，可以向数组中存放不同类型的数据 1let arr:[number, string] = [123, '123'] 枚举类型： 123enum Falg &#123;success=1, error=0&#125;let s:Falg = Falg.successconsole.log(s) // 1 any 类型： 相当于 没有指定类型，什么类型都可以用 因为ts的基本类型没有Object 类型，所以可以用 可以 用 any 类型替代 Object 类型，比如获取dom 节点的时候 变量 显式声明 1let a:number = 12; 声明 a 为一个 number 类型 类型推断 1let a = 12; typescript 语法会默认为 a 为一个 number 类型 不定义类型 方法一： 12let a;a = 12; ​ 方法二： 1let a:any = 12; 此时 a 没有类型， 可以给 a 再赋值其他类型的值 ts中的函数参数123function show(a:number, b:number) &#123; return a + b&#125; 返回值定义返回值类型需要定义在 括号后面 123function show(a:number, b:number):number &#123; return a + b&#125; 没有返回值 123function show (): void &#123; alert('aaa')&#125; 可选参数在js中，形参和实参个数不需要一致，但ts 必须一致，如果不一致需要在形参中说明 123function getInfo(name:string, age?:number) &#123; // 问号代表这个参数可以不传 &#125; 注意： 可选参数必须写在参数位置的最后面 默认参数和 es6 一样，直接在参数后面用 = 给默认参数赋值 123function getInfo(name:string, age:number = 20) &#123; &#125; 这样在传入的时候只默认参数可以不用传值 函数的重载java 中 重载指的是 两个或两个以上的同名函数 ，他们的参数不一样，这样会出现函数的重载 typeScript中 的重载是 同一个函数，根据不同的参数类型的定义实现重载 12345678910111213function getInfo(name:string):string;function getInfo(age:number):number;function getInfo(str:any):any &#123; if(typeof str === 'string') &#123; return str &#125; else &#123; return str + 10 &#125;&#125;getInfo('123') // 123getInfo(123)//123getInfo(ture) // 报错 类访问修饰符 public 公开的，所有都能访问修改 private 私有的，只有自己类的内部才可以访问 protected 受保护的，只有自己类和子类才可以访问 例如： 12345678910111213141516171819202122232425262728293031323334353637383940class Person &#123; public name:string; private age:number; protected gender:string; constructor(name:string, age:number, gender:string ) &#123; this.name = name; this.age = age; this.gender = gender &#125; protected show():void &#123; console.log(`我的名字叫$&#123;this.name&#125;,年龄为 $&#123;this.age&#125;`); &#125;&#125;class Staff extends Person &#123; private job: string; constructor(name:string, age:number, gender:string, job:string) &#123; super(name,age,gender) this.job = job &#125; show():void &#123; super.show(); //调用父类的 show 方法 console.log(`我的名字叫$&#123;this.name&#125;`); //console.log(`我的年龄为$&#123;this.age&#125;`); 报错，age是私有属性，不能再子类访问 console.log(`我的性别为$&#123;this.gender&#125;`); // 可以在子类访问 console.log(`我的工作为$&#123;this.job&#125;`); &#125;&#125;let staff:Staff = new Staff('zhao', 18, '男','打杂的') staff.show() //外部访问 console.log(staff.name); // 正常，public 都能访问 console.log(staff.age); // 报错， private，内部访问 console.log(staff.gender); // 报错，protected，内部和子类访问 console.log(staff.job); // 报错，private， 内部访问 简写: 正常声明一个类 123456789101112131415class Person &#123; public name:string; private age:number; protected gender:string; constructor(name:string, age:number, gender:string ) &#123; this.name = name; this.age = age; this.gender = gender &#125; protected show():void &#123; console.log(`我的名字叫$&#123;this.name&#125;,年龄为 $&#123;this.age&#125;`); &#125;&#125; 简写 12345678910class Person &#123; //省略了 constructor(public name:string, private age:number, protected gender:string ) &#123; //也省略了 &#125; protected show():void &#123; console.log(`我的名字叫$&#123;this.name&#125;,年龄为 $&#123;this.age&#125;`); &#125;&#125; 静态属性、静态方法用 static 关键字修饰的 属性和方法为静态方法，静态属性和方法不需要实例化对象，直接用 类名.方法名或属性名调用 123456789101112131415161718192021222324class Per &#123; // 静态属性 static gender: string = '男' constructor(public name:string, public age:number, ) &#123; &#125; // 这是一个实例方法 run():void &#123; console.log(`$&#123;this.name&#125;在运动`); &#125; // 这是一个静态方法 static print():void &#123; console.log(`print 静态方法`); &#125;&#125;let zhao = new Per('zhao',18)// 调用实例方法zhao.run() // 调用静态方法Per.print()console.log(Per.gender); 多态 父类定义一个方法不去实现，让继承它的子类去实现，每一个子类有不同的表现 1234567891011121314151617181920212223242526272829class Animal &#123; constructor(public name:string) &#123; &#125; eat():void&#123; // 具体吃什么不知道，具体吃什么?继承它的子类去实现，每一个子类的表现不一样 console.log(`吃`); &#125;&#125;class Dog extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat():string &#123; return `狗吃狗粮` &#125;&#125;class cat extends Animal &#123; constructor(name: string) &#123; super(name) &#125; eat(): string &#123; return `猫吃猫粮` &#125;&#125;let cat1 = new cat('miao')console.log(cat1.eat()); 抽象类和抽象方法 typeScript 中的抽象类，提供其他类的基类，不能直接被实例化 用 abstract 关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象类和抽象方法定义了一套模板，继承于它的子类必须遵循这个模板 1234567891011121314151617181920abstract class Animal2 &#123; constructor(public name:string) &#123; &#125; // 抽象方法只需要定义，不用实现 abstract eat():any&#125;class Student extends Animal2 &#123; constructor(name:string) &#123; super(name) &#125; // 抽象类中的方法必须实现 eat():string&#123; return `$&#123;this.name&#125;吃肉` &#125;&#125;let z = new Student('zhao')console.log(z.eat()); 接口 接口：可以对属性、函数、索引、类等进行定义和动作规范 接口需要用 interface 申明 作用：定义标准 属性接口对传入的json进行约束 12345678910// 约束函数接收一个 对象，对象有一个 label为 string 类型的属性function PrintLabel(labelInfo:&#123;label:string&#125;) &#123; console.log('zhao'); &#125;PrintLabel(&#123;label: 'zhao'&#125;) // √PrintLabel('zhao') // ×PrintLabel(&#123;name: 'zhao'&#125;) //× 定义接口，对所有方法进行约束 1234567891011121314151617181920212223// 定义一个接口interface fullName &#123; firstName:string // 这里的对象不用 逗号 要么用分号，要么不用符号 secondName:string &#125; function printName(name:fullName) &#123; console.log(name.firstName,name.secondName); &#125;// 如果在调用的时候直接传入对象，则只能传入接口规定的属性printName(&#123;firstName:'zhang', secondName: 'zhao'&#125;) // √printName(&#123; firstName: 'zhang', secondName: 'zhao', age: 18 &#125;) // ×// 如果对象中需要传入其他属性，则需要将对象抽离出来let obj = &#123; firstName: 'zhang', secondName: 'zhao', age: 20&#125;printName(obj) // √ 可选参数接口 接口中的属性可以不用传入 1234interface fullName &#123; firstName: string secondName?: string&#125; 类似于函数的可选参数，直接在属性名后面加上一个 问号表示这个非必须 函数接口对方法传入的参数以及返回值进行约束 12345678910// 函数类型的接口interface encrypt&#123; (param1:number, param2:number):number // 约定函数必须传入两个 number 类型的参数 并且返回一个number类型&#125;// 使用接口定义函数let enc:encrypt=function(param1: number, param2: number):number&#123; return param1 + param2&#125;enc(1,2) 类 类型接口对类的约束，类似于抽象类 用 implement 对 类接口的实现 12345678910111213interface Animal &#123; name:string eat(str:string):void&#125;class Dog5 implements Animal &#123; constructor(public name:string) &#123;&#125; eat() &#123; console.log(`$&#123;this.name&#125; 吃`); &#125;&#125;let d = new Dog5('zhao')d.eat() 接口扩展接口可以继承接口 123456789101112131415161718interface Animal &#123; eat():void&#125;interface P extends Animal &#123; work():void&#125;class Wor implements P&#123; constructor(public name:string) &#123;&#125; eat(): void &#123; console.log('吃'); &#125; work(): void &#123; console.log('搬砖'); &#125;&#125; 泛型 泛型就是解决 类、接口、方法的复用，以及对不特定数据类型的支持 泛型函数 123456// &lt;T&gt; 代表泛型function getName&lt;T&gt;(value:T):T &#123; return value&#125;// 使用泛型函数时候在 &lt;&gt; 中填入什么类型， T 就是什么类型getName&lt;string&gt;('zhao') 泛型类 1234567891011121314151617181920212223242526class Minclass&lt;T&gt; &#123; constructor(public list:T[] = []) &#123; &#125; add(value:T):void&#123; this.list.push(value) &#125; min():T &#123; let minNum = this.list[0] for (let i = 0; i &lt; this.list.length; i++) &#123; if (minNum &gt; this.list[i]) &#123; minNum = this.list[i] &#125; &#125; return minNum &#125;&#125;let m1 = new Minclass&lt;number&gt;()m1.add(1)m1.add(11)m1.add(21)m1.add(31)m1.add(41)console.log(m1.list); // [ 1, 11, 21, 31, 41 ]console.log(m1.min()); // 1 装饰器 装饰器就是一种特殊的类型声明，它能够附加到类的声明、方法 属性或者参数上，可以修改行为 通俗来说，装饰器就是一个方法，可以注入到类，方法，属性参数上来对他们进行扩展 装饰器还只是一种ts实验，使用的时候需要在 tsconfig.js 中配置 “experimentalDecorators”: true, (59行) 类装饰器1234567891011121314151617// 类装饰器 ---装饰器就是一个方法function logClass(params:any) &#123; console.log(params); // 当前类，就是使用他的类 params.prototype.apiUrl = '动态添加的类' params.prototype.run = function () &#123; console.log('这是一个run方法') &#125;&#125;@logClassclass Use&#123; constructor()&#123;&#125; getData()&#123;&#125;&#125;let u:any = new Use()u.run() // 此方法由装饰器注入，可以直接调用 装饰器工厂（可以向装饰器中出传递参数） 装饰器中的参数是 传入的参数 返回的函数中的参数是 使用的类 123456789101112131415161718function logClass(params:string) &#123; // 装饰器中的参数是 传入的参数） return function (fn:any) &#123; // 返回的函数中的参数是 使用的类 console.log(params); // http://www.zhangzhaozhao.work console.log(fn); // [Function: PrintUrl] fn.prototype.url = params &#125;&#125;@logClass('http://www.zhangzhaozhao.work')class PrintUrl &#123; constructor() &#123; &#125;&#125;let u:any = new PrintUrl()console.log(u.url); // http://www.zhangzhaozhao.work 用装饰器重载类的构造器和方法 123456789101112131415161718192021222324252627// 装饰器修改类的方法function logClass (params:any) &#123; console.log(params) return class extends params&#123; // 重新类里面的方法 apiUrl:string = '这是修改后的apiUrl' getData() &#123; this.apiUrl = this.apiUrl + '---' console.log(this.apiUrl); &#125; &#125;&#125;@logClassclass PrintUrl&#123; public apiUrl:string | undefined constructor() &#123; this.apiUrl = '这是构造函数里面的apiUrl' &#125; getData () &#123; console.log(this.apiUrl) &#125;&#125;let pp:any = new PrintUrl()pp.getData() 属性装饰器 属性装饰器表达式在运行时当作函数调用，传入两个参数 对静态成员来说是类的构造函数，对实例成员来说是类的原型对象 属性的名字 123456789101112131415161718192021222324252627// 类装饰器function logClass(params:string):any &#123; return function (fn:any) &#123;&#125;&#125;// 属性装饰器function logProperty (params:any):any &#123; // params 为传入的参数 return function (fn:any, attr:any) &#123; console.log(fn) // printUrl 类 console.log(attr) // url （属性名） fn[attr] = params &#125;&#125;// 类的装饰器@logClass('xxx')class printUrl &#123; // 属性的装饰器 @logProperty('hello-zhao') public url:any | undefined constructor () &#123;&#125; getData () &#123; console.log(this.url); &#125;&#125;let c = new printUrl()c.getData() 方法装饰器 他会被用到方法的属性描述上，可以用来监视，修改或替换方法定义 方法装饰器接收三个参数 对静态成员来说是类的构造函数，对实例成员来说是类的原型对象 方法名 当前方法的描述的描述 123456789101112131415161718192021222324252627// 方法装饰器function get (params:any) &#123; return function (target:any, methodName:any, desc:any) &#123; console.log(target); // printUrl &#123; getData: [Function] &#125; console.log(methodName); // getData console.log(desc); target.apiUrl = 'http://' target.run = function () &#123; console.log('it\'s a function run'); &#125; &#125;&#125;class printUrl &#123; public url:string | undefined constructor () &#123;&#125; // 使用方法装饰器 @get('zhao') getData () &#123; console.log(this.url); &#125;&#125;let pu:any = new printUrl()pu.run() // it's a function runconsole.log(pu.apiUrl); // http:// 方法装饰器修改原来方法 1234567891011121314151617181920212223242526272829function get(params: any) &#123; return function (target: any, methodName: any, desc: any) &#123; let oMethod = desc.value // 这个就是装饰器装饰的方法 // 替换这个方法 desc.value = function (...args:any[]) &#123; args = args.map(value =&gt; &#123; return String(value) &#125;) console.log(args); // this 指的是 desc.value 也就是 getData方法 oMethod.apply (this,args) &#125; &#125;&#125;class printUrl &#123; public url: string | undefined constructor() &#123; &#125; @get('zhao') getData(...args:any[]) &#123; console.log(args); // 此时这里打印的就是 string类型的数组 console.log('原来的方法'); &#125;&#125;let pu: any = new printUrl()pu.getData(123, 'sss') 装饰器的执行顺序属性 &gt; 方法&gt; 类 如果由多个同类型的装饰器则 由下到上，有后往前 执行]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typtScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典和散列]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[字典和散列字典 在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组 创建字典我们将 key 转化为了字符串，而为了保存信息的需要，我们同样要保存原始的 key。 创建一个将key转换成字符串的函数 difaultToString.js 1234567891011function difaultToString(item) &#123; if (item == null) &#123; return 'NULL' &#125; else if (item == undefined) &#123; return 'UNDEFINED' &#125; else if (typeof item === 'string' || item instanceof String) &#123; return `$&#123;item&#125;` &#125; return item.toString()&#125;module.exports = difaultToString 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const defaultToString = require('./../util/defaultToString')// 保存原始的 key：valuclass ValuePair &#123; constructor(key, value) &#123; this.key = key this.value = value &#125; toString () &#123; return `[#$&#123;this.key&#125;: $&#123;this.valve&#125;]` &#125;&#125;class Dictionary &#123; constructor (toStrfn = defaultToString) &#123; this.toStrfn = toStrfn this.table = &#123;&#125; &#125; // 检测一个键是否存在于字典中 hasKey (key) &#123; return this.table[this.toStrfn(key)] != null &#125; // 向字典中添加新元素。如果 key 已经存在，那么已存在的 value 会 被新的值覆盖 set (key, value) &#123; if (key != null &amp;&amp; value != null) &#123; const tableKey = this.toStrfn(key) this.table[tableKey] = new ValuePair(key, value) return true &#125; return false &#125; // 从字典中移除一个值 remove (key) &#123; if (this.hasKey(key)) &#123; delete this.table[this.toStrfn(key)] return true &#125; return false &#125; // 从字典中检索一个值 get (key) &#123; return this.table[this.toStrfn(key)] == null ? undefined : this.table[this.toStrfn(key)].value &#125; // 将字典中所有[键，值]对返回 keyValues() &#123; return Object.values(this.table) &#125; // 将字典所包含的所有键名以数组形式返回 keys () &#123; return this.keyValues().map(valuepair =&gt; valuepair.key) &#125; // 将字典所包含的所有值以数组形式返回 values () &#123; return this.keyValues().map(valuepair =&gt; valuepair.value) &#125; // 用 forEach 迭代字典中的每个键值对 forEach (callback) &#123; const valuepair = this.keyValues() for (let i = 0; i &lt; valuepair.length; i++) &#123; const result = callback(valuepair[i].key, valuepair[i].value) if (result === false) &#123; break &#125; &#125; &#125; size () &#123; return Object.keys(this.table).length &#125; isEmpty () &#123; return this.size() === 0 &#125; clear () &#123; this.table = &#123;&#125; &#125;&#125; 散列 散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果要在数据结构中获得一个值（使用 get 方法），需要迭代整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字典和散列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2019%2F06%2F30%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合 集合是由一组无序且唯一（即不能重复）的项组成的。该数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中 自己创建一个集合（Set)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 创建一个集合class Set &#123; constructor () &#123; this.items = &#123;&#125; &#125; // 检查元素是否存在在集合中 has (ele) &#123; // return ele in this.items // 或者 return Object.prototype.hasOwnProperty.call(this.items, ele) &#125; // 给集合里面添加元素 add (ele) &#123; if (!this.has(ele)) &#123; this.items[ele] = ele return true &#125; return false &#125; // 删除集合元素 delete (ele) &#123; if (this.has(ele)) &#123; delete this.items[ele] return true &#125; return false &#125; // 清空集合 clear () &#123; this.items = &#123;&#125; &#125; // 获取集合的长度 size () &#123; // es6 方法，将对象中的键转换成数组，再获取长度 // return Object.keys(this.items).length // es5 方法 let count = 0 for (const key in this.items) &#123; if (this.items.hasOwnProperty(key)) &#123; count++ &#125; &#125; return count &#125; // 将集合里面的值转换成数组 values () &#123; // es6 方法 // return Object.values(this.items) // es5 方法 let values = [] for (const key in this.items) &#123; if (this.items.hasOwnProperty(key)) &#123; values.push(this.items[key]) &#125; &#125; return values &#125;&#125;module.exports = Set 集合运算直接用 es6 api 实现 并集 对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。 123456789/** * 求两个集合的并集 * @param &#123;Set&#125; set1 集合1 * @param &#123;Set&#125; set2 集合2 */let union = (set1, set2) =&gt; new Set([...set1, ...set2])console.log(union(new Set([1, 3, 2, 5]), new Set([1, 2, 8, 9])));// Set &#123; 1, 3, 2, 5, 8, 9 &#125; 交集 对于给定的两个集合，返回一个包含两个集合中共有元素的新集合 12345678/** * 求两个集合的交集 * @param &#123;Set&#125; set1 集合1 * @param &#123;Set&#125; set2 集合2 */let intersection = (set1, set2) =&gt; new Set(Array.from(set1).filter(ele =&gt; set2.has(ele)))console.log(intersection(new Set([1, 3, 2, 5]), new Set([1, 2, 8, 9]))); 差集 对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集 合的元素的新集合 12345678/** * 求 集合1 与 集合2 差集 * @param &#123;Set&#125; set1 集合1 * @param &#123;Set&#125; set2 集合2 */let difference = (set1, set2) =&gt; new Set(Array.from(set1).filter(ele =&gt; !set2.has(ele)))console.log(difference(new Set([1, 3, 2, 5]), new Set([1, 2, 8, 9])));// Set &#123; 3, 5 &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F06%2F28%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用 初始化链表链表的节点类 Node.js 12345678// 节点类class Node &#123; constructor (element) &#123; this.element = element this.next = undefined &#125;&#125;module.exports = Node this.next 存储下一个节点对象 所以在js中，链表的存储结构为 当前节点对象里面嵌套下一个节点对象 最后一个节点的 this.next 为undefined 初始化链表及常用方法 initLinikList.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const Node = require('./Node')class LinkList &#123; constructor () &#123; // 存储元素的数量 this.count = 0 // 存储整个 this.head = undefined &#125; // 向链表尾部添加元素 push (ele) &#123; let node = new Node(ele) let current if (this.head == null) &#123; this.head = node &#125; else &#123; // current 的赋值为 第一个节点 current = this.head // current 从第一个节点移动到最后一个节点 while (current.next != null) &#123; current = current.next &#125; current.next = node &#125; this.count++ &#125; // 返回一个元素的位置 indexOf(ele) &#123; let current = this.head for (let i = 0; i &lt; this.count; i++) &#123; if (current.element === ele) &#123; return i &#125; current = current.next &#125; return -1 &#125; // 获取链表节点方法 getElementAt (index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;= this.count) &#123; let node = this.head for(let i = 0; i &lt; index &amp;&amp; node != null; i++) &#123; node = node.next &#125; return node &#125; return undefined &#125; // 从链表中移除指定位置元素 removeAt (index) &#123; // 判断索引边界 if (index &gt;= 0 &amp;&amp; index &lt; this.count) &#123; let current = this.head if (index === 0) &#123; this.head = current.next &#125; else &#123; let previous = this.getElementAt(index - 1) current = previous.next previous.next = current.next &#125; this.count-- return current.element &#125; return undefined &#125; // 从链表中移除元素 remove (ele) &#123; let index = this.indexOf(ele) if (index === -1) &#123; return 'input Error' &#125; return this.removeAt(index) &#125; // 任意位置插入元素 insert (ele, index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;= this.count) &#123; let node = new Node(ele) if (index === 0) &#123; node.next = this.head this.head = node &#125; else &#123; let previous = this.getElementAt(index - 1) node.next = previous.next previous.next = node &#125; this.count++ return true &#125; return false &#125; size () &#123; return this.count &#125; inEmpty () &#123; return this.size() === 0 &#125; toString() &#123; if (this.head == null) &#123; return ''; &#125; let objString = `$&#123;this.head.element&#125;`; let current = this.head.next; for (let i = 1; i &lt; this.size() &amp;&amp; current != null; i++) &#123; objString = `$&#123;objString&#125;,$&#123;current.element&#125;`; current = current.next; &#125; return objString; &#125;&#125;module.exports = LinkList 双向链表 双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接；而在双向链表中，链接是双向的：一个链向下一个元素， 另一个链向前一个元素 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 双链表的实现let Node = require('./Node')let LinkList = require('./initLInkList')// 双链表节点类，继承于普通链表节点类class DoublyNode extends Node &#123; constructor (element, next, prev) &#123; super(element, next) this.prev = prev &#125;&#125;// 双链表，继承于普通链表class DoublyLinkList extends LinkList &#123; constructor () &#123; super() // 用来存储最后一个节点对象 this.tail = undefined &#125; insert (ele, index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;=this.count) &#123; const node = new DoublyNode(ele) let current = this.head if (index === 0) &#123; // 链表为空 if (this.head == null) &#123; this.head = node this.tail = node &#125; else &#123; node.next = this.head current.prev = node this.head = node &#125; // 给链表末尾添加节点 &#125; else if (index === this.count) &#123; current = this.tail current.next = node node.prev = current this.tail = node &#125; else &#123; const previous = this.getElementAt(index - 1) current = previous.next node.next = current previous.next = node current.prev = node node.prev = previous &#125; this.count++ return true &#125; return false &#125; // 从任意位置移除元素 removeAt (index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; this.count) &#123; let current = this.head if (index === 0) &#123; this.head = current.next // 如果只有一项，更新tail if (this.count === 1) &#123; this.tail = undefined &#125; else &#123; this.head.prev = undefined &#125; // 移除最后一个节点 &#125; else if (index === this.count -1) &#123; current = this.tail this.tail = current.prev current.prev.next = undefined // 移除中间节点 &#125; else &#123; current = this.getElementAt(index) current.prev.next = current.next current.next.prev = current.prev &#125; this.count-- return current.element &#125; return undefined &#125;&#125;let testLinkList = new DoublyLinkList()testLinkList.insert(5, 0)testLinkList.insert(2, 1)testLinkList.insert(8, 2)console.log(testLinkList.removeAt(2)); 循环链表 循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用 undefined，而是指向第一个元素（head） 循环链表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 循环链表的实现let Node = require('./Node')let LinkList = require('./initLInkList')class CircularLinkLidst extends LinkList &#123; constructor () &#123; super () &#125; insert (ele, index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;= this.count) &#123; const node = new Node(ele) let current = this.head if (index === 0) &#123; if (this.head == null) &#123; this.head = node // 最后一个节点的next 指向头节点 node.next = this.head &#125; else &#123; node.next = current // 获取最后一个节点 current = this.getElementAt(this.size()) this.head = node current.next = this.head &#125; &#125; else &#123; const previous = this.getElementAt(index - 1) node.next = previous.next previous.next = node &#125; this.count++ return true &#125; return false &#125; removeAt(index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; this.count) &#123; let current = this.head if (index === 0) &#123; if (this.size() === 1) &#123; this.head = undefined &#125; else &#123; const removed = this.head current = this.getElementAt(this.size()) this.head = this.head.next current.next = this.head current = removed &#125; &#125; else &#123; const previous = this.getElementAt(index -1) current = previous.next previous.next = current.next &#125; this.count-- return current.element &#125; return false &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2019%2F06%2F24%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列先入先出 创建队列通过闭包和 WeakMap 将 items 封装成私有的属性 initQueue 1234567891011121314151617181920212223242526272829303132333435363738let Queue = (function () &#123; const items = new WeakMap() class Queue &#123; constructor () &#123; items.set(this, []) &#125; // 入队 enqueue (ele) &#123; let q = items.get(this) q.push(ele) &#125; // 出队 dequeue () &#123; let q = items.get(this) let r = q.shift() return r &#125; // 查看队列是否为空 isEmpty () &#123; let q = items.get(this) return q.length === 0 &#125; // 打印队列 print () &#123; let q = items.get(this) console.log(q.toString()); &#125; &#125; // 返回队列元素个数 size () &#123; let q = items.get(this) return q.length &#125; return Queue&#125;) () module.exports = Queue 优先队列在入队的时候给元素优先级，使其不一定要插到队尾 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 优先队列的构造函数function PriorityQueue () &#123; let items = [] // 元素的构造函数 function Element (ele, pri) &#123; this.element = ele this.priority = pri &#125; // 优先队列的入队函数 this.enqueue = function (ele, pri) &#123; // 初始化一个元素对象 let element = new Element(ele, pri) // 队列为空，则元素对象入队 if (this.isEmpty()) &#123; items.push(element) &#125; else &#123; let flag = false // 判断要插入的元素对象的优先级，和 队列元素的优先级，如果优先级高，插入到当前队列之前 for(let i = 0; i &lt; items.length; i++) &#123; if (element.priority &lt; items[i].priority) &#123; items.splice(i, 0, element) flag = true break &#125; &#125; // 优先级小于所有数组元素的优先级，插入到队尾 if (!flag) &#123; items.push(element) &#125; &#125; &#125; this.isEmpty = function () &#123; return items.length === 0 &#125; this.print = function () &#123; for(let i = 0; i &lt; items.length; i++) &#123; console.log(items[i].element, items[i].priority); &#125; &#125;&#125;var priorityQueue = new PriorityQueue();priorityQueue.enqueue('john', 2);priorityQueue.enqueue('jack', 1);priorityQueue.enqueue('camila', 1);priorityQueue.print();//jack 1camila 1john 2 循环队列123456789101112131415161718192021222324252627282930313233343536// 用循环队列模仿击鼓传花游戏/* 在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。 某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈、结束游戏。 重复这个过程，直到只剩一个孩子（胜者）*/const Queue = require('./initQueue')/** * 模拟击鼓传花游戏 * @param &#123;Array&#125; nameList 参加游戏的小朋友 * @param &#123;Number&#125; num 每一回合花在小朋友中传递的次数 */function hotPotato(nameList, num) &#123; let queue = new Queue() let eliminatedList = [] // 将小朋友的名字入队列 for(let i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]) &#125; while (queue.size() &gt; 1) &#123; for(let i = 0; i &lt; num; i++) &#123; // 传过的小朋友先出队列，在排到队尾 queue.enqueue(queue.dequeue()) &#125; eliminatedList.push(queue.dequeue()) &#125; return &#123; winner: queue.dequeue(), eliminatedList &#125;&#125;let name = ['a', 'b', 'c', 'd', 'e']let result = hotPotato(name, 7)console.log(result);// &#123; winner: 'a', eliminatedList: [ 'c', 'b', 'e', 'd' ] &#125; 双端队列双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列 在计算机科学中，双端队列的一个常见应用是存储一系列的撤销操作。每当用户在软件中进行了一个操作，该操作会被存在一个双端队列中（就像在一个栈里）。当用户点击撤销按钮时， 该操作会被从双端队列中弹出，表示它被从后面移除了。在进行了预先定义的一定数量的操作后， 最先进行的操作会被从双端队列的前端移除。由于双端队列同时遵守了先进先出和后进先出原 则，可以说它是把队列和栈相结合的一种数据结构 初始化双端队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 双端队列class Deque &#123; constructor () &#123; this.count = 0 this.lowestCount = 0 this.items = &#123;&#125; &#125; // 判断双端队列是否为空 isEmpty () &#123; return this.count - this.lowestCount === 0 &#125; // 从双端队列前端移除第一个元素 removeFront () &#123; if (this.isEmpty()) &#123; return undefined &#125; let result = this.items[this.lowestCount] delete this.items[this.lowestCount] this.lowestCount++ return result &#125; // 从双端队列后端移除第一个元素 removeBack () &#123; if (this.isEmpty()) &#123; return undefined &#125; let result = this.items[this.count - 1] delete this.items[this.count - 1] this.count-- return result &#125; // 返回双端队列前端的第一个元素 peekFront () &#123; return this.items[this.lowestCount] &#125; // 返回双端队列前端的第一个元素 peekBack () &#123; return this.items[this.count -1] &#125; clear () &#123; this.items = &#123;&#125; this.count = 0 this.lowestCount = 0 &#125; size () &#123; return this.count - this.lowestCount &#125; print () &#123; if (this.isEmpty()) &#123; return [] &#125; let res = [] for(let i = this.lowestCount; i &lt; this.count; i++) &#123; res.push(this.items[i]) &#125; return res &#125; // 在双端队列队尾添加元素 addBack(ele) &#123; this.items[this.count] = ele this.count++ &#125; // 在双端队列前端添加新的元素 addFront(ele) &#123; if (this.isEmpty()) &#123; this.addBack(ele) &#125; else &#123; this.lowestCount -- this.items[this.lowestCount] = ele &#125; &#125;&#125;module.exports = Deque 用双端队列检查回文 回文是正反都能读通的单词、词组、数或一系列字符的序列，例如madam或 racecar 123456789101112131415161718192021222324let Deque = require('./initDeque')function palindromeChecker(aString) &#123; if (aString === undefined || aString === null || (aString !== null &amp;&amp; aString.length === 0)) &#123; return false &#125; const deque = new Deque() const lowerString = aString.toLocaleLowerCase() let isEqual = true let firstChar, lastChar // 元素入队 for(let i = 0; i &lt; lowerString.length; i++) &#123; deque.addBack(lowerString.charAt(i)) &#125; while (deque.size() &gt; 1 &amp;&amp; isEqual) &#123; firstChar = deque.removeFront() lastChar = deque.removeBack() if (firstChar !== lastChar) &#123; isEqual = false &#125; &#125; return isEqual&#125;console.log(palindromeChecker('aaabaaa'));]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈(Stack)先入后出 实现ES5 用构造函数表示栈 用数组作为存储对象 将栈的方法挂载到构造函数的原型上 123456789101112131415161718192021222324// 创建栈function Stack () &#123; // 用数组作为存储方法 this.items = []&#125;Stack.prototype.push = function (element) &#123; this.items.push(element)&#125;Stack.prototype.pop = function () &#123; return this.items.pop()&#125;Stack.prototype.peek = function () &#123; return this.items[this.items.length - 1]&#125;Stack.prototype.isEmpty = function () &#123; return this.items.length === 0&#125;//创建一个栈的实例对象let stack = new Stack()console.log(stack.isEmpty());stack.push(2)console.log(stack.items); ES6 用类实现 123456789class Stack &#123; constructor () &#123; this.item = [] &#125; push (element) &#123; this.items.push(element) &#125;&#125; 简单案例十进制转换二进制封装一个栈的类 1234567891011121314151617181920212223242526272829303132// 封装的栈class Stack &#123; constructor() &#123; this.items = [] &#125; push(element) &#123; this.items.push(element) &#125; pop() &#123; return this.items.pop() &#125; peek() &#123; return this.items[this.items.length - 1] &#125; isEmpty() &#123; return this.items.length === 0 &#125; size() &#123; return this.items.length &#125; clear() &#123; this.items = [] &#125; print() &#123; let result = '' while (!this.isEmpty()) &#123; result += this.pop().toString() &#125; console.log(result); &#125;&#125;module.exports = Stack 算法实现 12345678910111213141516171819// 引入封装的栈const Stack = require('./封装一个栈')/** * 十进制转换二进制方法 * @param &#123;Number&#125; num 要准换的十进制数 */function Ten2Two (num) &#123; let stack = new Stack() let rem while (num &gt; 0) &#123; rem = Math.floor(num % 2) stack.push(rem) num = Math.floor(num / 2) &#125; stack.print()&#125;Ten2Two(233)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组封装]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E7%BB%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[数组数组元素操作方法添加元素尾插 length Array.length 可以获取数组的长度，同时这个返回的长度是数组索引的最大值 + 1 1arr[arr.length] = x 表示给数组的最后添加一个元素 x push 方法 push()方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 简单实现 123456Array.prototype.myPush = function () &#123; for(let i = 0; i &lt; arguments.length; i++) &#123; this[this.length] = arguments[i] &#125; return this.length&#125; 首插 unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。 简单实现 123456789Array.prototype.myUnshift =function () &#123; for (let j = 0; j &lt; arguments.length; j++) &#123; for (let i = this.length; i &gt; 0; i--) &#123; this[i] = this[i - 1]; &#125; this[0] = arguments[j]; &#125; return this.length;&#125; 删除元素尾删 pop() 删除末尾元素，并返回这个元素 1arr.pop() 简单实现 12345678Array.prototype.myPop = function() &#123; if (this.length === 0) &#123; return &#125; let last = this[this.length - 1] this.length-- return last&#125; 首删 shift() 方法从数组中删除第一个元素，并返回该元素的值 简单实现 1234567891011Array.prototype.myShift = function () &#123; let head = this[0] if (this.length === 0) &#123; return &#125; for(let i = 0; i &lt; this.length; i++) &#123; this[i] = this[i + 1] &#125; this.length-- return head&#125; 在任意位置添加或删除 splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 参数： 第一个：起始计算索引 第二个：删除的元素个数 其余：添加的元素 简单实现 123456789101112131415161718192021222324252627282930313233343536373839Array.prototype.mySplice = function () &#123; let start = arguments[0] let deleteLen = arguments[1] let len = arguments.length let instertEles = [] if (len &lt; 2) &#123; this.length = start &#125; else if (len === 2) &#123; for(let i = start; i &lt; this.length; i++) &#123; this[i] = this[i + deleteLen] &#125; this.length = this.length - deleteLen &#125; else &#123; // 获取添加元素 for (let j = arguments.length - 1; j &gt;= 2; j--) &#123; instertEles.unshift(arguments[j]) &#125; // 删除元素 if (deleteLen &gt;= this.length - start) &#123; this.length = start &#125; else &#123; for (let i = start; i &lt; this.length; i++) &#123; this[i] = this[i + deleteLen] &#125; this.length = this.length - deleteLen &#125; // 添加元素 for(let i = 0; i&lt; instertEles.length; i++) &#123; for(let j = this.length; j &gt; start; j--) &#123; this[j] = this[j - 1] &#125; this[start] = instertEles[i] start++ &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nuxt]]></title>
    <url>%2F2019%2F06%2F11%2Fnuxt%2F</url>
    <content type="text"><![CDATA[vue 服务端渲染 和 nuxt服务端优缺点优点有利于SEO 缺点页面在服务器上渲染，增大服务器压力，不利于高并发 简单的vue服务端渲染安装 1npm i vue-server-renderer -S 简单应用 1234567891011121314151617181920212223242526const Vue = require('vue')const renderer = require('vue-server-renderer').createRenderer()const server = require('express')()// vue 部分let app = new Vue(&#123; template:`&lt;h1&gt;Hello World !! &#123;&#123; name &#125;&#125;&lt;/h1&gt;`, data() &#123; return &#123; name: 'zhao' &#125; &#125;&#125;)// node 部分server.get('*', (req, res) =&gt; &#123; // 将渲染的 template 转换成字符串 renderer.renderToString(app, (err, html) =&gt; &#123; if (err) &#123; console.log(err); return &#125; res.send(html) &#125;)&#125;)server.listen(8888) nuxtnuxt vue的服务端渲染框架 官方文档 上车安装 1npx create-nuxt-app &lt;项目名&gt; nuxt 的目录结构dome ├─.nuxt │ ├─components │ └─views ├─assets // 存放为编译的静态资源，less，sass ，java ├─components // 组件目录 ├─layouts // 布局目录 ├─middleware // 中间件目录 ├─pages // 页面目录 ├─plugins // 插件目录 ├─server // 服务器文件目录 ├─static // 静态目录，不会通过webpack打包 └─store // 存放 vuex 的目录]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2019%2F05%2F31%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack 4上车安装 1webpack webpack-cli -D webpack4 可以 0 配置，但功能不全 入口文件为 项目根目录下面的 src/index.js 打包输出文件为 项目根目录下面的 dist/main.js 打包: 1npx webpack 手动配置执行配置文件执行默认配置 在当前项目根目录下新建一个 webpack.config.js 这是 webpack 默认执行的配置文件 修改默认配置 建立自己的 webpack 配置文件 xxx.js 1npx webpack --config xxx.js 或者给 package.json 添加脚本 123"scripts": &#123; "bulid" "webpack --config xxx.js"&#125; 执行 1npm run bulid webpack基础配置123456789const path = require('path')module.exports = &#123; mode: 'development', // 模式 有两种： production development entry: './src/index.js', // 打包的入口文件 output: &#123; filename: 'bundle.js', // 打包后的文件名 path: path.resolve(__dirname, 'dist') // 打包文件存放目录 &#125;&#125; webpack-dev-server 配置开发服务器，在内存中打包，不会生成真的打包文件，方便修改 安装 1yarn add webpack-dev-server -D 基本配置 12345678devServer: &#123; // 开发服务器配置 port: 3000, // 设置端口 progress: true, // 显示打包进度条 contentBase: './dist', // 指定打包后的开发文件在 dist 目录，这样就可以被 dist 目录其他文件引用 compress: true, // gzip 压缩 proxy：&#123; ‘/api/*’: 'http://localhost:3000' // 将/api/ 的请求用 http://localhost:3000 代理&#125; 插件所有的插件都放在 plugins： [] html-webpack-plugin 插件作用:是将 src 目录下面的 js 文件 自动引入到 src 目录下面的 html 文件里，并将 引入后的 html 文件 打包到 dist 目录 安装 html-webpack-plugin 1yarn html-webpack-plugin -D 引入 1let HtmlWebpackPlugin = require('html-webpack-plugin') 基本配置 1234567891011plugins: [ // 数组，存放着所有的 webpack 插件 new HtmlWebpackPlugin (&#123; template: './src/index.html', // 引入的 html 文件 filename: 'index.html', // 打包后的文件名 minify: &#123; // 对 html 文件的压缩 removeAttributeQuotes: true, // 删除双引号 collapseWhitespace: true, //删除多余的空格和 空行 &#125;, hash: true, // 打包的 js 文件添加 hash 防止文件覆盖 &#125;) ] mini-css-extract-plugin 插件作用： 将 css 文件抽离成单独的文件 安装 1yarn add mini-css-extract-plugin -D 引入 1let MiniCssExtractPlugin = require('mini-css-extract-plugin') 配置 123new MiniCssExtractPlugin(&#123; filename: 'main.css' //导出的 css 文件名称&#125;) 同时需要用 MiniCssExtractPlugin.loader 替换 style-loader 如： 12345678&#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, //将打包的 css 引入到 html文件中 'css-loader', 'postcss-loader', //解析css 自动添加浏览器前缀 ]&#125; 模块用于解析打包不同的文件 解析 css 文件安装loader 1yarn css-loader style-loader postcss-loader autoprefixer -D loader css-loader：解析在 css 文件中用 @import 导入的其他css style-loader：将 css 添加到 head 标签中 postcss-loader 自动为 css 添加浏览器前缀 loader 的执行是由顺序的 ：从右向左，从下到上解析 注意： 使用 postcss-loader 需要添加配置文件 在 项目根目录 新建一个 postcss.config.js 的文件 放入 123module.exports = &#123; plugins: [require('autoprefixer')]&#125; 基本配置 1234567891011121314151617module: &#123; rules: [ // 规则 &#123; test: /\.css$/, use: [ &#123; // 可以将 loader 写成对象形式，也可以直接引用 loader: 'style-loader', options: &#123; insertAt: 'top' //将 css 文件插入到 head 标签顶部，方便可以让自己的html中 css覆盖 &#125; &#125;, 'css-loader'， 'postcss-loader', //给 css 自动添加浏览器前缀 ] &#125; ]&#125; 解析 less安装loader 1yarn css-loader style-loader less less-loader postcss-loader autoprefixer -D 配置 1234567891011121314&#123; test: /\.less$/, use: [ &#123; loader: 'style-loader', options: &#123; insertAt: 'top' &#125; &#125;, 'css-loader', 'less-loader'， 'postcss-loader' ]&#125; 高版本es 转化成es5安装babel 12yarn add babel-loader @babel/core @babel/preset-env babel-plugin-transform-runtime @babel/plugin-proposal-class-properties -Dyarn add @babel/runtime @babel/polyfill 配置 1234567891011121314151617181920&#123; test: /\.js$/, use: [ &#123; loader:'babel-loader', options: &#123; // 用babel-loader 将es6 -&gt; es5 presets: [ '@babel/preset-env' ], plugins: [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], ["@babel/plugin-proposal-class-properties", &#123; "loose": true &#125;], ["@babel/plugin-transform-runtime"] ] &#125; &#125; ], exclude: /node_modules/, // 排除文件 include: path.resolve(__dirname, 'src') // 打包的文件&#125; 配置eslint校验 js 代码规范 安装loader 1yarn add eslint eslint-loader -D 配置 123456789&#123; test: /\.js$/, use: &#123; loader: 'eslint-loader', options: &#123; enforce: 'pre' // 强制提前执行 &#125; &#125;&#125;, 同时需要在根目录安装一个 .eslintrc.json 的配置文件 这里下载 打包图片安装loader 1yarn add file-loader -D 作用：默认在内部生成一张图片，到dist 目录下，返回生成的图片名 配置 1234567891011121314&#123; test: /\.html/, use: 'html-withimg-loader' // 将html中的图片打包到 dist 目录&#125;, &#123; test: /\.(jpg|jpeg|png|gif)$/, use: &#123; loader: 'url-loader', // 将小于 200K的图片变成base64格式 options: &#123; limit: 200 * 1024, outputPath: 'img/' // 大于200k 的图片放到 /dist/img 下面 &#125; &#125; &#125;, 多入口配置打包成多个文件 1234567891011121314151617181920212223module.exports = &#123; mode: 'development', entry: &#123; //打包两个 js 文件 index: './src/index.js', others: './src/other.js' &#125;, output: &#123; filename: '[name].js', // [name] -&gt; index &amp; others path: path.resolve(__dirname, 'dist') &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', chunks: ['index'] // 导出的 html 只引入 index.js &#125;), new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'other.html', chunks: ['othwes'] &#125;), ]&#125; 实时监控打包文件123456watch: true, watchOptions: &#123; poll: 1000, aggregateTimeout: 500, // 防抖, 停止输入后 500ms 后重新打包 ignored: /node_modules/ &#125; resolve配置解析第三方模块的规则和次序 1234567resolve: &#123; modules: [path.resolve('node_modules')]， // 查找第三方模块只在当前的 node_modules 文件中找 extensions: ['.js', '.vue'] // 引入这些类型的文件不用写扩展名 alias: &#123; @: './src/components' // 配置别名，用@ 代替后面的地址 &#125;，&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务部署]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[CentOS上车联网用 vim 打开 vi /etc/sysconfig/network-scripts/ifcfg-xxx(xxx为网卡后缀，每个人的都不一样) 修改： 1ONBOOT=no 为 ONBOOT=yes 重启网络 123service network restart//或者/etc/init.d/network restart 更新系统、软件1234// 系统和软件全部更新yum update -y// 只更新软件yum upgrade 更换源备份原来的源 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 更换为网易的源 安装wget 1yum install wget 换源 12wget http://mirrors.163.com/.help/CentOS7-Base-163.repomv CentOS7-Base-163.repo /etc/yum.repos.d/ 重置 12yum clean allyum makecash vim安装vim 1yum install vim -y vim使用vim file 打开或创建 file 文件 vim的三种模式 命令模式 进入 vim 默认进入命令模式， 在命令模式输入当前命令 插入模式 键入 i 进入插入模式，在插入模式输入直接写的文件 底行模式 esc 返回命令模式， shift + ：进入底行模式，在底行模式输入当作底行命令 底行命令 :q(退出不保存) :w（保存文件） :wq(保存并退出) q！（强制退出） 安装服务node将 node 添加到 yum 源中 1curl --silent --location https://rpm.nodesource.com/setup_10.x | sudo bash - 安装 1yum install nodejs -y 用 vim 写一个简单的 nodejs 服务，发现主机访问不了 需要配置防护墙 配置防火墙1234// 清除防火墙配置iptables -F// 允许 8080 端口访问iptables -A INPUT -p tcp --dport 8080 -j ACCEPT nginx安装添加 源 1vim /etc/yum.repos.d/nginx.repo 添加 12345678910111213[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.key 安装 1yum install nginx -y 配置进入配置文件 1vim /etc/nginx/conf.d/default.conf 原配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; ----&gt;监听的端口 server_name localhost; -----&gt; 服务器名称 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; -------&gt;服务文件目录 index index.html index.htm; -------&gt; 默认的服务文件 &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; 配置代理服务 1234567891011121314151617server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm index.php index.asp; &#125; #将 /node 代理成 http://localhost:8080 location /node &#123; #代理后重新设置一个请求头，用来覆盖原来的请求头 proxy_set_header host $host; proxy_pass http://localhost:8080/; &#125; 配置完成后就可以将 ip /node 代理成 local host:8080 还需要修改 1setsebool -P httpd_can_network_connect 1 重启服务 1/usr/sbin/nginx -s reload mariadb安装 12yum install mariadb-server -ymysql_install_db 配置 1cp /usr/share/mysql/my-xxx.cng /etc/my.cnf 启动 1service mariadb start 添加密码 1mysqladmin -u root password 修改数据库配置，使其可以远程连接 进入数据库 1grant all privileges on *.* to root@&apos;%&apos; identified by &apos;123456&apos;; 这样就可以在本机用数据库管理工具访问数据库 上传程序pm2安装 pm2 1npm i -g pm2 用 pm2 启动服务 1pm2 start xxx.js --name test 启动 xxx.js 文件 并命名为 test 查看启动服务列表 1pm2 list 停止服务 1pm2 stop 服务名 | id 从 pm2 中删除服务 1pm2 delete 服务名 | id]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue通信&vuex]]></title>
    <url>%2F2019%2F05%2F13%2FVue%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%26Vuex%2F</url>
    <content type="text"><![CDATA[vue 数据通信vue 组件间通信父传子父组件 父组件在子组件上使用 key=value 的方式向子组件发送信息 123456789101112131415161718192021222324&lt;template&gt; &lt;ul&gt; &lt;ListItem v-for=&quot;item in items&quot; :data=&quot;item&quot; str=&quot;aaa&quot;&gt;&lt;/ListItem&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import ListItem from &apos;./list_item&apos;export default &#123; name: &apos;&apos;, data () &#123; return &#123; items: [ &#123;name: &apos;aaa&apos;, price: 355, salse: 552&#125;, &#123;name: &apos;bbb&apos;, price: 66, salse: 554&#125;, &#123;name: &apos;ccc&apos;, price: 22, salse: 66&#125;, &#123;name: &apos;ddd&apos;, price: 555, salse: 88&#125;, &#123;name: &apos;eee&apos;, price: 15, salse: 22&#125; ] &#125; &#125;, components: &#123;ListItem&#125;,&#125;&lt;/script&gt; props 方法 接收 父组件传递的信息 子组件中 使用 proops:[&#39;父组件中传递的key&#39;] 子组件接收后，就可直接使用父组件传递的信息 子组件 123456789101112131415161718192021222324&lt;template&gt; &lt;li&gt; &lt;h3&gt;名称：&#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;p&gt;价格&#123;&#123;data.price&#125;&#125;&lt;/p&gt; &lt;p&gt;月销：&#123;&#123;data.salse&#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;ListItem&apos;, props: [&apos;data&apos;], data () &#123; return &#123; text: &apos;&apos;, data2: &#123;&#125; &#125; &#125;, mounted () &#123; console.log(this.$attrs); &#125;,&#125;&lt;/script&gt; $attrs 接收父组件传递的信息$attrs 是一个对象，接收的是 子组件中没有通过 props 接收的值， 如果 通过props 接收了，则用$attrs接收不到 1234567891011121314151617181920212223&lt;template&gt; &lt;li&gt; &lt;h3&gt;商品名称:&#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;p&gt;价格:&#123;&#123;data.price&#125;&#125;&lt;/p&gt; &lt;p&gt;月销：&#123;&#123;data.salse&#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;ListItem&apos;, data () &#123; return &#123; data: &#123;&#125; &#125; &#125;, mounted () &#123; this.data = this.$attrs.data &#125;&#125;&lt;/script&gt; 子传父父组件向子组件传递自己的方法 父组件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; 已选中&#123;&#123;count&#125;&#125;件 &lt;ul&gt; &lt;ListItem v-for=&quot;item in items&quot; :data=&quot;item&quot; str=&quot;aaa&quot; :add=&quot;addOne&quot; :minus=&quot;minusOne&quot;&gt;&lt;/ListItem&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ListItem from &apos;./list_item&apos;export default &#123; name: &apos;&apos;, data () &#123; return &#123; count: 0, items: [ &#123;name: &apos;aaa&apos;, price: 355, salse: 552&#125;, &#123;name: &apos;bbb&apos;, price: 66, salse: 554&#125;, &#123;name: &apos;ccc&apos;, price: 22, salse: 66&#125;, &#123;name: &apos;ddd&apos;, price: 555, salse: 88&#125;, &#123;name: &apos;eee&apos;, price: 15, salse: 22&#125; ] &#125; &#125;, components: &#123;ListItem&#125;, methods: &#123; addOne () &#123; this.count++ &#125;, minusOne () &#123; this.count-- &#125; &#125;&#125;&lt;/script&gt; 子组件 子组件公共 $attrs 接收父组件传递的方法，调用这个方法，实现通信 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;li&gt; &lt;h3&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;商品名称:&#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;p&gt;价格:&#123;&#123;data.price&#125;&#125;&lt;/p&gt; &lt;p&gt;月销：&#123;&#123;data.salse&#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;ListItem&apos;, data () &#123; return &#123; checked: false, data: &#123;&#125; &#125; &#125;, mounted () &#123; this.data = this.$attrs.data &#125;, watch: &#123; checked () &#123; if (this.checked) &#123; // 子组件调用父组件的方法，实现通信 this.$attrs.add() &#125; else &#123; this.$attrs.minus() &#125; &#125; &#125;,&#125;&lt;/script&gt; axios 和 fetchaxios 和 fetch 都是 对 xmlhttprequest 的封装 12345data () &#123; return &#123; items: [] &#125; &#125;, axios文档 简单使用 123456789101112// 引入axiosimport axios from 'axios'// 将其添加到vue的原型对象上Vue.prototype.axios = axiosasync mounted () &#123; try &#123; this.items = (await this.axios.get('http://localhost:3000/list')).data &#125; catch (err) &#123; console.log(err); &#125;&#125;, fetchfetch 是官方对 xhmhttprequest 的封装 文档 简单使用 1234567async mounted () &#123; try &#123; this.items = await (await fetch('http://localhost:3000/list')).json() &#125; catch (err) &#123; console.log(err); &#125;&#125;, 用 (await fetch(&#39;http://localhost:3000/list&#39;)).json() 获取请求数据，返回的是一个 Promise 对象， 所以还需要 await一下 vuex 统一状态管理Vuex 简介什么是VuexVuex 是专门为 Vue.js 应用程序开发的状态管理模式 为什么要用Vuex当我们构建一个中大型的单页面应用程序时，Vuex 可以更好的帮助我们在组件外部统一管理状态 Vuex 的核心state State 是唯一的数据源 单一的状态树 组件中可以用 this.$store.state.[所要获取数据] 用组件的 computed 来监听 state 里面的值的变化 12345computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;, 当 vuex 中的count 改变，会触发computed 中的 count 从而对数据进行更新 mutations 更改 Vuex 中 store 中的状态唯一的方法就是提交 mutation 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, `mutations`: &#123; increment(state) &#123; // 只能用 mutations 改变 state.conunt++ &#125; &#125;&#125;) 组件中触发vuex 1$store.commit('increment') 直接掉用 mutations 里面的方法 改变 state 里面的值 actions actions 提交的是 mutation， 而不是直接变更状态 actions 可以包含任意的异步操作 123456789101112131415const store = new Vuex.Store(&#123; state:&#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, `actions`: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) 组件中触发vuex 1this.$store.dispatch('increment') 先触发 actions 里面的方法，再触发 mutations 的方法，修改 state 里面的值 getters 通过 getters 可以派生出一些新的状态 如： 12345678910111213const store = new Vuex Store(&#123; state: &#123; todos: [ &#123;id: 1;,texi:'...',done:true&#125;, &#123;id: 2;,texi:'...',done:false&#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Modules 面对复杂的应用程序，当管理的状态比较多时，需要将Vuex 的store 对象分割成模块（modules），每一个模块都是一个store对象 123456789// 引入两个子模块import user from './user'import article from './article'// 使用子模块modules: &#123; user, article &#125; user模块 12345678910111213141516171819export default &#123; state: &#123; name: 'zhao', age: 22 &#125;, mutations: &#123; setAge (state, arg) &#123; state.age = arg &#125; &#125;, actions: &#123; setAge (&#123;commit&#125;, arg) &#123; commit('setAge', arg) &#125; &#125;, getters: &#123; &#125;&#125; 注意： 在组件中获取模块中的 state 需要 this.$store.state.[模块名].[state属性] 用dispatch可以直接触发 子模块的 actions 的方法 如：this.$store.dispatch(&#39;setAge&#39;, 12) 如果子模块和父模块中的 actions 中用相同的方法，则这些方法全部触发]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter]]></title>
    <url>%2F2019%2F04%2F16%2FVueRouter%2F</url>
    <content type="text"><![CDATA[路由前端路由的本质是锚点值改变，页面不跳转，但改变 innerHtml的内容 123456789101112131415161718&lt;body&gt; &lt;a href="#/login"&gt;点我登陆&lt;/a&gt; &lt;a href="#/register"&gt;点我注册&lt;/a&gt; &lt;div id="div"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; let div = document.querySelector('div') window.addEventListener('hashchange',()=&gt;&#123; switch(location.hash) &#123; case '#/login': div.innerHTML = '&lt;h1&gt;登陆&lt;/h1&gt;' break; case '#/register': div.innerHTML = '&lt;h1&gt;注册&lt;/h1&gt;' break; &#125; &#125; )&lt;/script&gt; 路由其实是由 hash 完成的（基于hashchange事件） 监听 url 上锚点（#xxx）的变化改变页面的内容（锚点和 hash 一回事） vue 路由路由使用步骤： 引入vue-router路由（插件）对象 安装插件 创建路由对象 配置路由对象 指定路由改变的位置 将配置好的 路由对象 关联到 vue 实例中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;!-- 1. 引入vue-router路由（插件）对象 --&gt;&lt;script src="./node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;&lt;script&gt; // 2. 安装插件 Vue.use(VueRouter); // 需要显示的组件 let login = &#123; template:`&lt;div&gt; 登陆 &lt;/div&gt;` &#125; let register = &#123; template:`&lt;div&gt; 注册&lt;/div&gt;` &#125; // 3.创建路由对象 let router = new VueRouter(&#123; // 4. 配置路由对象 routes:[ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;) // 5. 指定路由改变的位置 let app = &#123; template: ` &lt;div&gt; &lt;router-link to="/login"&gt;注册&lt;/router-link&gt; &lt;router-link to="/register"&gt;登陆&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; ` &#125; // 6. 将配置好的 路由对象 关联到 vue 实例中 new Vue(&#123; el:'#app', components: &#123; app &#125;, router, template:'&lt;app/&gt;', &#125;)&lt;/script&gt; vue中的路由是切换组件，并不是页面切换。 router-link 其实就是一个 a 标签 router-view 是一个占位符，需要路由的地方就需要 router-view 路由参数 用 $route.params 获取 路由参数 /:123 用 $route.query 获取 问号参数 /a=123 用 beforRouteUpdate(to, from, next)监听路由变化 也可以用 watch 监听路由变化 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;div id="div1"&gt; &lt;router-link to="/article/1"&gt;文章1&lt;/router-link&gt; &lt;router-link to="/article/5"&gt;文章2&lt;/router-link&gt; &lt;router-link to="/article/10"&gt;文章3&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let router = new VueRouter(&#123; routes: [&#123; path: '/article/:id', component: &#123; // $route 记录当前路由信息 template: '&lt;div&gt;文章的id：&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;', beforeRouteUpdate(to, from, next)&#123; if (confirm('如果离开，修改不会保存')) &#123; next(); &#125; &#125; &#125; &#125;], &#125;); new Vue(&#123; el: '#div1', router, watch: &#123; // 监听路由变化 $route(newVal, oldVal) &#123; console.log('从', oldVal); console.log('变到', newVal); &#125; &#125; &#125;)&lt;/script&gt; 命名路由 给路由对象一个名称，相当于一个存储路由路径的变量 123// name 属性的值相当于一个变量，存储了路由的来路径 &#123; name:'login', path: '/login', component: login &#125;, &#123; name:'register', path: '/register', component: register &#125; 在 router-link 的 to 属性中通过对象描述这个规则 123&lt;router-link :to="&#123;name: 'login'&#125;"&gt;注册&lt;/router-link&gt; &lt;router-link :to="&#123;name: 'register'&#125;"&gt;登陆&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; 路由嵌套路由包含子路由，视图（router-view）包含变化的子视图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="./node_modules/vue/dist/vue.js "&gt;&lt;/script&gt; &lt;script src="./node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; &lt;script&gt; let login = &#123; template: `&lt;div&gt; login路由，下面是子路由显示的内容 &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125; let vip = &#123; template: ` &lt;div&gt; vip 登陆 &lt;/div&gt; ` &#125; let register = &#123; template: `&lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125; let app = &#123; template: ` &lt;div&gt; &lt;router-link :to="&#123; name:'vip'&#125;"&gt;去vip&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125; let router = new VueRouter(&#123; routes:[ &#123; path: '/login', name: 'login', component: login, children: [ &#123; path: 'vip', name: 'vip', component: vip &#125; ] &#125; ] &#125;) Vue.use(VueRouter) new Vue(&#123; el:'#app', router, components: &#123; app &#125;, template: '&lt;app/&gt;' &#125;) &lt;/script&gt;&lt;/body&gt; 子路由只需要在父级路由中加上一个 children 的数组，里面配置自己的路由 metameta 是对于路由规则是否需要验证权限的配置 路由对象中，和 name 属性同级 1meta:&#123;isChicked:true&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="./node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;&lt;script&gt; let isLogin = false Vue.use(VueRouter); let login = &#123; template: `&lt;div&gt; 登陆界面，不登陆，不显示音乐界面 &lt;/div&gt;`, // 组件创建之后 created () &#123; isLogin = true &#125; &#125; let music = &#123; template: `&lt;div&gt; 音乐界面&lt;/div&gt;` &#125; let router = new VueRouter() // 追加路由对象 router.addRoutes([ // 默认首页路由 &#123; path: '/', redirect: &#123;name: 'login'&#125; &#125;, &#123; name:'login', path: '/login', component: login &#125;, &#123; name:'music', path: '/music', component: music, // 路由守卫（权限控制） meta: &#123; isChick:true &#125; &#125; ]) router.beforeEach((to, from, next) =&gt; &#123; // to: 要去的路由对象 // from： 从哪里去的 路由对象 // next() 继续执行 if (!to.meta.isChick) &#123; next() &#125;else&#123; if (isLogin) &#123; next() &#125; else&#123; // 重定向 next(&#123;name: 'login'&#125;) &#125; &#125; &#125;) // 5. 指定路由改变的位置 let app = &#123; template: ` &lt;div&gt; &lt;router-link :to="&#123;name:'login'&#125;"&gt;登陆&lt;/router-link&gt; &lt;router-link :to="&#123;name:'music'&#125;"&gt;音乐&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; ` &#125; // 6. 将配置好的 路由对象 关联到 vue 实例中 new Vue(&#123; el: '#app', components: &#123; app &#125;, router, template: '&lt;app/&gt;', &#125;)&lt;/script&gt; 编程导航 跳转到指定锚点，并显示页面 1this.$router.push&#123;name:'xxx',query:&#123;id:1&#125;,params:&#123;name:'abc'&#125;&#125; 根据历史记录前进或后退 1this.$router.go(1 | -1) ​ 1 前进，-1 后退]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥vue]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%88%9D%E7%AA%A5vue%2F</url>
    <content type="text"><![CDATA[vue双向数据绑定一向js 内存属性的改变，影响页面的变化 二向页面的改变影响 js 内存的改变 起步12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; // 启动 Vue new Vue(&#123; // vue 监管的区域 el: '#app', // dom 结构 template: '&lt;div&gt;大家好 &#123;&#123; text &#125;&#125;&lt;/div&gt;', // 存放变量 data()&#123; return &#123; text: 'hello vue' &#125; &#125; &#125;)&lt;/script&gt; vue 的常见指令 v-text ： 是元素的innerText 只能在双标签中使用 v-html ： 是元素的 innerHTML 不能有 v-if ： 元素是否移除（删除元素） v-show ： 元素是否显示或隐藏 v-model： 双向数据绑定（内存js和页面的变化相互影响） v-bind: 单向数据绑定（内存js 影响页面） 多用于属性绑定 123v-bind:title = "txt"//简写:title = "txt" v-on： 用于事件绑定 可以简写 @: 1234567891011121314151617181920212223&lt;script&gt; window.onload = function () &#123; let vm = new Vue(&#123; el: '#div1', data: &#123; cont: 0 &#125;, methods:&#123; fnClick() &#123; this.cont ++ &#125; &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; &#123;&#123; cont &#125;&#125; &lt;br&gt; &lt;span v-on:click = "fnClick"&gt;点击试试&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; v-for: 用于循环 1234567891011121314151617181920212223242526 &lt;script&gt; window.onload = ()=&gt; &#123; let vm = new Vue(&#123; el: '#div1', data: &#123; users: [ &#123; id:11 ,name: '张三', age: 18 &#125;, &#123; id:13 ,name: '张三', age: 19 &#125;, &#123; id:18 ,name: '张三', age: 20 &#125;, &#123; id:120, name: '张三', age: 21 &#125;, ] &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;ul&gt; //用 key 绑定 数据中一个不会变的值，这样可以将 每一条数据和相应的视图所对应，在数据发生变化的时候，可以直接修改这个视图 &lt;li v-for="item,index in users" :key="users.id"&gt; &#123;&#123; index &#125;&#125;姓名: &#123;&#123;item.name&#125;&#125;, 年龄： &#123;&#123; item.age &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 组件组件的使用 第一步：创建组件 第二步：声明组件（components) 1components:&#123;'组件名'，组件对象&#125; 第三步：使用组件（template） 组件需要放在一个标签下 可以通过&lt;组件名&gt;&lt;/组件名&gt;使用 也可以通过&lt;组件名/&gt;使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; // 创建子组件 let MyHeader = &#123; template: ` &lt;div&gt; 我是header组件 &lt;/div&gt; ` &#125; let MyFooter = &#123; template: ` &lt;div&gt; 我是footer组件 &lt;/div&gt; ` &#125; // 入口组件(父组件) let App = &#123; // 声明使用子组件 components: &#123; 'my-header': MyHeader, 'my-footer': MyFooter &#125;, // 使用子组件 template: ` &lt;div&gt; &lt;my-header/&gt; &lt;my-footer/&gt; &lt;/div&gt; ` &#125; new Vue(&#123; el: '#app', // 声明使用父组件 components: &#123; app: App &#125;, // 使用父组件 template: '&lt;app/&gt;' &#125;)&lt;/script&gt; 父传子 父组件使用子组件时通过属性传递 子组件要声明 props[‘属性名’] 来接收 子组件收到父组件后在 template 中直接使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; // 创建子组件 let Son = &#123; template: ` &lt;div&gt; 接收到父组件的数据是 &#123;&#123; title &#125;&#125; &lt;h1&gt;1&lt;/h1&gt; &lt;h1&gt;2&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;改变显示&lt;/button&gt; &lt;/div&gt; `, // 声明接收参数 props:['title'] &#125; // 声明入口组件 // 父向子传递， 就是 v-bind 给元素的属性赋值 let App = &#123; // 声明子组件 components: &#123; son:Son &#125;, template: ` &lt;h1&gt; &lt;!-- 父传子--&gt; &lt;son :title="xxx"&gt;&lt;/son&gt; 我是入口组件 &lt;/h1&gt;`, data()&#123; return &#123; xxx: '我是 xxx 数据' &#125; &#125; &#125; new Vue(&#123; el: '#app', // 声明要使用的组件 components: &#123; app: App &#125;, template: '&lt;app/&gt;',//入口组件 &#125;)&lt;/script&gt; 注册全局组件应用场景：将公共组件注册成为全局组件，在使用全局组件时候不用声明，减少代码冗余 写法： 1Vue.component('组件名'，组件对象) 例如： 1234567891011121314151617// 注册公共的全局组件 Vue.component('my-btn',&#123; template: ` &lt;button&gt; 全局组件 button &lt;/button&gt; ` &#125;) // 创建子组件 let MyHeader = &#123; template: ` &lt;div&gt; 我是header组件 &lt;my-btn/&gt; &lt;/div&gt; ` &#125; 在子组件中直接使用 my-btn 组件 slot作用：父元素向子元素传递 dom 节点 用法：通过 vue 提供的 例如 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; // &lt;slot&gt;&lt;/slot&gt; 是一个占位符，具体内容可以在使用时自定义 let myLi = &#123; template: ` &lt;li&gt; &lt;slot name="one"&gt;&lt;/slot&gt; &lt;slot name="two"&gt;&lt;/slot&gt; &lt;/li&gt;` &#125; // 将 myLi 注册成为全局组件 Vue.component('my-li', myLi) let app = &#123; template: ` &lt;div&gt; &lt;ul&gt; 第一个slot &lt;my-li&gt;&lt;button slot="one"&gt;1&lt;/button&gt;&lt;/my-li&gt; 第二个slot &lt;my-li&gt; &lt;h1 slot="two"&gt;2&lt;/h1&gt; &lt;/my-li&gt; &lt;/ul&gt; &lt;/div&gt; ` &#125; new Vue(&#123; el: '#app', components: &#123; app &#125;, template: '&lt;app/&gt;' &#125;)&lt;/script&gt; 标签可以有多个 slot 有一个name 属性，用来作为标识 用其他元素填充 时候，需要给这个元素加一个 slot 属性，属性的值要和name 的属性值相同，这样此元素可以填充对应的 组件的生命周期 beforeCreate 和 created beforeCreate：表示：在组件创建之前 created：组件创建之后 created 可以操作数据，实现 vue -&gt; 页面的影响 通常用来 发起 ajax 请求 使用该组件就会触发以上的事件函数（钩子函数） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; let test = &#123; template: ` &lt;div&gt; 我是 test 组件 &lt;/div&gt; `, data () &#123; return &#123; text:'zhao' &#125; &#125;, beforeCreate () &#123; console.log(this.text); //undefined &#125;, created () &#123; console.log(this.text); //zhao &#125; &#125; let app = &#123; components: &#123; test &#125;, template: ` &lt;div&gt; &lt;test/&gt; &lt;/div&gt; ` &#125; new Vue(&#123; el: '#app', components: &#123; app &#125;, template: '&lt;app/&gt;' &#125;)&lt;/script&gt; beforeMount 和 Mounted beforeMount：vue 还没有装载的组件的 dom Mounted：vue 装载后的组件后的 dom 1234567891011121314151617 beforeMount () &#123; console.log(document.body.innerHTML); //没有装载的组件的 dom // &lt;div id="app"&gt;&lt;/div&gt; &#125;, // vue 装载数据到 dom 之后 mounted () &#123; console.log(document.body.innerHTML); //装载后的组件后的 dom // &lt;div&gt; // &lt;div&gt; // 我是 test 组件 // &lt;/div&gt; // &lt;/div&gt; &#125;&#125; beforeUpdate 和 updated beforeUpdate：基于数据页面数据改变之前的 dom updated：页面数据改变后 dom beforeDestroy 和 destroyed beforeDestroy：组件对象销毁之前 destroyed：组件对象销毁之后 以上的两个事件，必须和 父组件的 v-if false 配合使用4 销毁，最终都是做一些其他功能的释放，比如销毁之前将数据保存到localStorage 频繁发销毁和创建组件不利于页面的渲染，vue 中 提供了将销毁的组件包裹，这样可以控制组件的激活和停用 12345678910template: ` &lt;div&gt; &lt;keep-alive&gt; &lt;test v-if="isExist"&gt;&lt;/test&gt; &lt;/keep-alive&gt; &lt;button @click="isExist=!isExist&gt;切换&lt;/button&gt; &lt;/div&gt; ` activated 和 deactivated activated：用于判断组件是否被激活 deactivated：用于判断组件是否停用 过滤器（filter） filter 全局过滤器 1Vue.filter('过滤器名','过滤方式') filters 组件自己的过滤器 反转字符串 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; let app = &#123; template: ` &lt;div&gt; &lt;input type="text" v-model="myText" /&gt; &lt;!-- 使用过滤器， 接收一个 myText 过滤后的值 --&gt; &#123;&#123; myText | reverse('你好') &#125;&#125; &lt;/div&gt; `, data() &#123; return &#123; myText: ''&#125; &#125;, methods: &#123; fn() &#123; &#125; &#125;, //设置过滤器 filters: &#123; //第一个参数为 myText 的值， 第二个为使用 reverse 传入的 reverse(oldVal, params) &#123; return params + ':' + oldVal.split('').reverse().join('') &#125; &#125; &#125; new Vue(&#123; el:'#app', components:&#123; app &#125;, template: '&lt;app/&gt;' &#125;)&lt;/script&gt; 跟 component 和 components 类似 监听（watch）基本监听只能监听基本数据类型， 因为简单数据类型的变量指向的是内存中的数据， 而而复杂数据类型指向的是其在内存中的地址。 复杂类型改变其地址不变，所以监听不到 1234567891011121314151617181920212223&lt;body&gt; &lt;div id="div1"&gt; &lt;input type="text" name="" id="" v-model="a"&gt; &lt;/div&gt;&lt;script&gt;window.onload = () =&gt;&#123; new Vue(&#123; el: '#div1', data: &#123; a: '' &#125;, // watch 用于监听变化， watch: &#123; // 第一个为 改变后的值，第二个为改变前的值 a(newVal, oldVal)&#123; console.log(`a从$&#123;oldVal&#125;变成$&#123;newVal&#125;`); &#125; &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt; 复杂监听可以监听到 复杂数据类型的改变 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; let app = &#123; template: ` &lt;div&gt; &lt;button @click="stus[0].name='zhang'"&gt;改变数组naem属性值&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; stus: [&#123;name:'zhao'&#125;] &#125; &#125;, // 深度监听 watch: &#123; stus:&#123; deep: true, handler(newVal, oldVal) &#123; console.log('改变了'); &#125; &#125; &#125; &#125; new Vue(&#123; el: '#app', components: &#123; app &#125;, template: '&lt;app/&gt;' &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6]]></title>
    <url>%2F2019%2F04%2F04%2Fes6%2F</url>
    <content type="text"><![CDATA[es6参考资料：阮一峰的es6 变量&amp;赋值var 的缺点 可以重复定义 不能限制修改 没有块级作用域 let和const对比： let 定义变量 有块级作用于 不能重复定义 声明不会提升 const 定义常量 有块级作用于 不能重复定义 声明不会提升 var 定义变量 没有块级作用域 可以重复定义会覆盖 声明会提升 经典用法解决for循环中的闭包 es6用法 12345678910111213141516&lt;body&gt; &lt;input type="button" value="1"&gt; &lt;input type="button" value="2"&gt; &lt;input type="button" value="3"&gt;&lt;/body&gt; &lt;script&gt; window.onload=function ()&#123; let aBtn=document.getElementsByTagName('input'); for(let i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].onclick=function ()&#123; alert(i); &#125;; &#125; &#125;; &lt;/script&gt; es5闭包实现 123456789101112131415161718&lt;body&gt; &lt;input type="button" value="1"&gt; &lt;input type="button" value="2"&gt; &lt;input type="button" value="3"&gt;&lt;/body&gt; &lt;script&gt; window.onload=function ()&#123; var aBtn=document.getElementsByTagName('input'); for(var i=0;i&lt;aBtn.length;i++)&#123; (function (i) &#123; aBtn[i].onclick=function ()&#123; alert(i); &#125;; &#125;)(i) &#125; &#125;;&lt;/script&gt; 结构赋值 数组：将等号右边的 按格式依次赋值给 等号左边 字面量对象： 等号右边的对象的属性和左边的变量名相同的匹配 12let [a,b,c] = [1,2,3]let&#123;a,b,c&#125; = &#123;a:1, b:2, c:3&#125; 函数箭头函数 es5 函数 123function (参数1，参数2) &#123; 函数体&#125; es6 函数 123(参数1，参数2)=&gt;&#123; 函数体&#125; 注意： 如果有且仅有一个参数 （）可以省略 如果函数体只是 return 返回的一句话 {} 可以省略 12345let show = function (a) &#123; return a*3&#125;show(3) //9 简写 123let show = a =&gt; a*3show(3)//9 默认参数在 es5 中 函数的参数没有默认值 但可以通过函数体实现 1234567function show (a, b, c) &#123; b = b || 2 c = c || 3 console.log(a+b+c)&#125;show(1) //6show(2,2,1) //5 es6 中 12345function show (a, b = 2, c = 3) &#123; console.log(a+b+c)&#125;show(1) //6show(2,2,1) //5 …运算符…名字 的用法 作用一: rest参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 123456function show(a,b,c,...f) &#123; console(a,b,c,f)&#125;show(1,2,3,4,5,6,7,8)//1 2 3 [4, 5, 6, 7, 8] 作用 二：扩展运算符 它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 123456let arr = [1,2,3,4]let arr2 = [9,10]arr.push(...arr2)console.log(arr)//[1,2,3,4,9,10] 数组&amp;jsonmap（映射）表示一对一的关系，如：给定成绩数组，返回对应是否及格数组 12345678910111213141516// [30,50,67,80,90,45]=&gt;[false,false,true,true,true,false]let arr = [30, 50, 67, 80, 90, 45] let arr2 = arr.map((item, index) =&gt; &#123; if (item &gt;= 60) &#123; return true &#125; else &#123; return false &#125; &#125;) console.log(arr2);//简写let arr2 = arr.map(item =&gt; item&gt;=60 )console.log(arr2); map 的返回值是一个新数组 filter（过滤）过滤掉不及格的成绩 1234let arr = [30, 50, 67, 80, 90, 45] let arr2 = arr.filter(item =&gt; item &gt;= 60) //item &gt;=60 将其返回，否则过滤掉 console.log(arr2); filter 返回也使一个新数组 forEach（遍历）求总成绩 123456let arr = [30, 50, 67, 80, 90, 45] let sum = 0; arr.forEach(item =&gt; &#123; sum += item &#125;) console.log(sum); reduce （减少）进去一堆，出来一个，多用于汇总 求和 参数 tem 为临时值，用于保存每次相加的结果 tmp 第一次 为 30 第二次 为 80 ​ … 147 123456let arr = [30, 50, 67, 80, 90, 45] let sum = arr.reduce((tmp, item, index) =&gt; &#123; return tmp +item &#125;) console.log(sum); set（集合）去除数组重复的元素 先将 数组转换成集合，再将集合转换成数组 123let arr = [30, 50, 67, 80, 90, 45,67, 80, 90, 45] let arr2 = Array.from(new Set(arr)) console.log(arr2); json 如果键值名字相同，可以只写一个 1234let a = 10let b = 12let json = &#123;a, b&#125; //相当于 let json = &#123;a: a, b: b&#125;console.log(json); 省略 function 123456789let a = 10 let b = 12 let json = &#123; a, b, show()&#123; return a + b &#125; &#125; 字符串字符串模板用 ``符号将字符串包裹，用 ${变量} 优点： 植入变量 可以行 12345678let json = &#123; age: 25, name: 'zhao' &#125; console.log('我叫' + json.name + '今年' + json.age); //用字符串模板 console.log(`我叫$&#123;json.name&#125;,今年$&#123;json.age&#125;`); 面向对象类 class 类名{} constructor（） {属性} 方法（）{} 12345678910111213141516class Person&#123; constructor(name, age) &#123; this.name = name; this.age = age &#125; showname() &#123; console.log(`我叫 $&#123;this.name&#125;`); &#125; showage() &#123; console.log(`我 $&#123;this.age&#125;`); &#125; &#125; let p = new Person('小米', 18) p.showname() //我叫 小米 p.showage() //我 18 继承 class 子类 extends 父类{} super（继承父类的属性） 1234567891011121314151617181920212223242526272829class Person&#123; constructor(name, age) &#123; this.name = name; this.age = age &#125; showname() &#123; console.log(`我叫 $&#123;this.name&#125;`); &#125; showage() &#123; console.log(`我 $&#123;this.age&#125;`); &#125; &#125;class Worker extends Person&#123; constructor(name, age, job) &#123; super(name, age); this.job = job; &#125; showjob() &#123; console.log(`我的工作是 $&#123;this.job&#125;`); &#125;&#125;let worker = new Worker('小米', 18, '打杂的')worker.showage() //我 18worker.showname() //我叫 小米worker.showjob() // 我的工作是 打杂的 静态方法 类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上static关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。 静态方法调用直接在类上进行，而在类的实例上不可被调用。 静态方法调用直接在类上进行，而在类的实例上不可被调用。 看下面的 es5 代码 12345678910111213141516171819var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;;Singleton.prototype.getName = function () &#123; alert(this.name);&#125;;// 静态方法Singleton.getInstance = function (name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;;var a = Singleton.getInstance('sven1'); var b = Singleton.getInstance('sven2'); alert(a === b); 上面的代码中 getInstance () 是直接挂载到 构造函数 Singleton 上面， 只能呗构造函数调用 所以在转换成 es6 的时候需要加上 static 123456789101112131415161718192021class Singleton &#123; constructor(name) &#123; this.name = name this.instance = null &#125; getName() &#123; console.log(this.name); &#125; // 静态方法 static getInstance(name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name) &#125; return this.instance &#125;&#125;let a = Singleton.getInstance('zhao1')let b = Singleton.getInstance('zhao2')console.log(a === b); promise 创建一个promise对象 1234let p = promise((resolve, reject) =&gt; &#123; &#125;)p.then (() =&gt;&#123;&#125;,() =&gt; &#123;&#125;) promise 对象中有两参数，一个表示请求成功后的回调函数，一个是请求失败的回调函数 then 方法接收两个函数，第一个是 resolve 的回调函数，第二个是 reject 的回调函数 使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let fs = require('fs')let p1 = new Promise( (resolve, reject) =&gt;&#123; fs.readFile('./data/a.txt', 'utf8', (err, data)=&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)let p2 = new Promise( (resolve, reject) =&gt;&#123; fs.readFile('./data/b.txt', 'utf8', (err, data)=&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)let p3 = new Promise( (resolve, reject) =&gt;&#123; fs.readFile('./data/c.txt', 'utf8', (err, data)=&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)p1 .then( (data) =&gt;&#123; console.log(data) // 当 p1 读取成功的时候 // 当前函数中 return 的结果就可以在后面的 then 中 function 接收到 // 真正有用的是：我们可以 return 一个 Promise 对象 // 当 return 一个 Promise 对象的时候，后续的 then 方法中的第一个参数会作为 p2 的 resolve return p2 &#125;, (err) =&gt;&#123; console.log('读取文件失败了', err) &#125;) .then( (data)=&gt; &#123; console.log(data) return p3 &#125;) .then( (data)=&gt; &#123; console.log(data) console.log('end') &#125;) promise.all 使用 promise.all 方法可以简化 then 方法的使用 1234567891011121314151617181920212223242526272829303132333435363738let p1 = new Promise( (resolve, reject) =&gt;&#123; fs.readFile('./data/a.txt', 'utf8', (err, data)=&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)let p2 = new Promise( (resolve, reject) =&gt;&#123; fs.readFile('./data/b.txt', 'utf8', (err, data)=&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)let p3 = new Promise( (resolve, reject) =&gt;&#123; fs.readFile('./data/c.txt', 'utf8', (err, data)=&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)Promise.all([p1,p2,p3]).then(arr =&gt; &#123; //解构赋值 let [a, b, c] =arr; alert('成功')&#125;,err=&gt; &#123; alert('失败')&#125;) all 方法中 以数组形式 传入promise 对象，后面 then 中用数组接收返回结果 generator generator 可以使函数 运行时暂停 yield 可以设置断点 generator 函数是有返回值的 执行 generator 函数 需要用到 返回值 中的 next() 方法 12345678910111213141516//创建一个 generator 函数function *show() &#123;&#125;//用 yield 可以设置 断点 ，function *show() &#123; alert('aaa') yield alert('bbb')&#125;//接收 generator 函数 的返回值let gen = show()//调用gen.next() //此时函数执行到 yield 处停止 // aaagen.next() //执行yield 下半部分 // bbb yield 传参 1234567891011function *show() &#123; alert('aaa') // 接受参数 let a = yield alert('bbb' + a) // bbb12&#125;let gen = show()gen.next() gen.next(12) //传参 返回 123456789101112function *show() &#123; alert('aaa') // 返回值 yield 55 alert('bbb') &#125;let gen = show()let res1 = gen.next() console.log(res1) // &#123;value: 55, done: false&#125;let res2 = gen.next() console.log(res2) // &#123;value: undefined, done: true&#125; done ，表示函数是否执行完成 async/await12345678910async function show () &#123; try&#123; let data1 = await $.ajax(url: '1.text',dataType: 'json') let data2 = await $.ajax(url: '2.text',dataType: 'json') let data3 = await $.ajax(url: '3.text',dataType: 'json') &#125; catch(e) &#123; alert('出错') &#125;&#125;show() async 中的 await 异步操作 会变成按顺序执行 ，同时返回成功的结果，可以用try-catch进行错误捕获，得到错误结果 编译——&gt;es5babel编译]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa]]></title>
    <url>%2F2019%2F03%2F31%2Fkoa%2F</url>
    <content type="text"><![CDATA[koakoa 中所有的异步操作都需要用 async /await 安装 1npm i koa koa-static koa-better-body koa-convert koa-router -D koa-static 用于开放静态资源 koa-better-body 用于解析 post 提交数据 koa-convert 用于兼容中间件 koa-router 用于路由 koa 入门 引入模块 使用 监听端口 1234const koa = require('koa')let server = new koa()server.listen(8888) 路由koa 对router 强依赖，不像 express 一样可以自带简单路由 express 中的简单路由 1234let server = expressserver.get('/', (req, res)=&gt;&#123; &#125;) 但是这个不能在 koa 中使用，要在 koa 中使用路由，必须 引入路由模块， 创建路由 配置中间件 123456789101112const koa = require('koa')const router = require('koa-router')let server = new koa()server.listen(8888)let router1 = router()server.use(router1.routes())router1.get('/', async(ctx, next) =&gt; &#123; &#125;) async 中的 ctx 对象 的重要属性 ctx. req 原生的 req 对象 ctx.request koa 封装的 req 对象 ctx.res 原生的 res 对象 ctx.response koa 封装的 res 对象 ctx.response 设置响应头 12//设置一个 a 的响应头， 值为 12ctx.response.set('a', 12) 设置返回内容 12//向浏览器返回jsonctx.response.body = &#123;a: 12, b: 25&#125; 设置状态码 1ctx.response.status = 403 ctx.request 获取请求头 1ctx.request.headers 开放静态文件， 返回文件开放 www 目录下的资源 123456789const koa = require('koa')const static = require('koa-static')const path = require('path')let server = new koa()server.listen(8888)// 路径转化成绝对路径server.use(static(path.resolve('./www'))) 如果 www 目录下面 有一个 1.html 我文件，则可以通过 http://localhost:8888/1.html请求 koa-static 存在问题 发送给浏览器的文件没有经过压缩 发送的文件不会缓存 解决方法 使用中间件 koa-static-cache 代替 koa-static 123456789const koa = require('koa')const staticCache = require('koa-static-cache')const path = require('path')let server = new koa()server.listen(8888)// 路径转化成绝对路径server.use(staticCache(path.resolve('./www'))) 数据处理获取 get 数据获取问号参数 1ctx.request.query 获取路由参数 1ctx.params 123456789101112131415const koa = require('koa')const router = require('koa-router')let server = new koa()server.listen(8888)let r1 = router()server.use(r1.routes())// 路由参数为 user，和 ager1.get('/:user/:age', async (ctx, next) =&gt; &#123; ctx.response.body = 'sadfasd' console.log(ctx.params); //&#123; user: '小明', age: '54' &#125; &#125;) 请求url：http://localhost:8888/小明/54 ， 获取 post 数据 引入第三方模块 koa-better-body，用来解析 post 提交的数据 引入 koa-convert ，用来 兼容 koa-better-body 在 koa2版本的使用 ctx.request.fields 可以获取 post 方式提交的 表单，文件信息 ctx.request.files 只能获取 post 方式提交的 文件信息 使用1234567891011121314151617181920212223242526const koa = require('koa')const betterBody = require('koa-better-body')const staticCache = require('koa-static-cache')const convert = require('koa-convert')const path = require('path')let server = new koa()server.listen(8888)// 开放静态资源server.use(staticCache(path.resolve('./www')))server.use(convert(betterBody(&#123; //保存提交的文件地址 uploadDir: path.resolve('./upload'), //是否保留上传文件的扩展名（一般不用保留） keepExtensions: true&#125;)))//不用路由，可以获取所有的提交server.use(async ctx =&gt; &#123; console.log(ctx.request.fields); console.log(ctx.request.files); &#125;) cookie&amp;sessioncookie 获取cookie 1ctx.cookies.get(cookie名字) 设置cookie 1ctx.cookes.set(cookie名字，值，option) session使用 第三方模块 koa- session 1const session = require('koa-session') 配置中间件 {}中填入session 的信息 1server.use(session(&#123;&#125;, server)) 使用 1ctx.session ejs 后端渲染安装 ejs 1const ejs = require('koa-ejs') 将模板文件创建在 template 目录下 名称为 template.html 使用 12345678910111213141516171819202122const koa = require('koa')const path = require('path')const ejs = require('koa-ejs')let server = new koa()server.listen(8888)ejs(server, &#123; //模板文件目录 root: path.resolve('template'), layout: false, //模板文件 扩展名 viewExt: 'html'&#125;)server.use(async ctx=&gt;&#123; //渲染文件 template，不用带扩展名，&#123;渲染数据&#125; await ctx.render('template', &#123; name: 'zhao', age: 20 &#125;)&#125;) MySQL引入中间件 1let db = require('mysql-pro') 优点: 事务管理（Transaction） 防止 SQL 注入 使用 1234567891011121314151617181920212223242526272829303132const koa = require('koa')const router = require('koa-router')const Mysql = require('mysql-pro')const db = new Mysql(&#123; mysql: &#123; host: 'localhost', port: '3306', user: 'root', password: '123456', database: 'test' &#125;&#125;)const server = new koa()server.listen(8888)let r1= router()server.use(r1.routes())r1.get('/user', async ctx=&gt; &#123; let id = ctx.query.id; // 开启事务 await db.startTransaction() //防止sql 注入 let data = await db.executeTransaction('SELECT * FROM user WHERE ID=?;',[id]) ctx.response.body = data //关闭事务 await db.stopTransaction()&#125;) 注意: 开启事务，对应着要关闭事务 为了防止 sql 注入，mysql-pro 要求将 需要的参数用 ? 代替，然后将参数用数组的形式放到语句后面。 事务（transaction）性质： A 原子性 事务内的事情，要么都发生，要么都不发生 C 持久性 只要事务提交，他的作用就是永久的 I 隔离性 各事务之间独立，不干扰 D 一致性 事务前后的状态一致]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express]]></title>
    <url>%2F2019%2F03%2F30%2Fexpress%2F</url>
    <content type="text"><![CDATA[express基本使用步骤123456789101112const experss = require('experss')let server = experss()server.listen(8888)server.get('/a', (req, res)=&gt;&#123; res.send('sadf') &#125;)//使用中间件 开放 www下面的静态资源server.use(experss.static('www/')) 中间件 插件 –补充框架的功能 类似于流水线 中间件的next()方法（流水线）12345678910111213141516171819const experss = require('experss')let server = experss()server.listen(8888)server.get('/a', (req, res, next)=&gt;&#123; res.send('sadf') console.log('sssssss'); next()&#125;)server.get('/a', (req, res, next) =&gt; &#123; console.log('dddddddddddd'); next()&#125;)server.use(experss.static('www/')) 添加了 next(), 程序会执行向下执行 路径path 模块中有 resolve() 方法 可以获取文件绝对路径 path.basename作用： 获取路径中的文件名 12345path.basename('c:a/b/c/d/index.js') 'index.js'path.basename('c:a/b/c/index.js', '.js') 'index' path.dirname作用： 获取文件目录 12path.dirname('c:a/b/c/index') c:a/b/c' path.extname作用： 获取文件扩展名 12path.extname('c:/a/b/c/index.js') '.js' path.isAbsolute作用: 判断是否为绝对路径 12345678path.isAbsolute('a/b/c/index') falsepath.isAbsolute('/a/b/c/index') truepath.isAbsolute('./a/b/c/index') false path.parse作用： 获取路径的所有信息 12345678path.parse('c:/a/b/c/index.html')//&#123; root: 'c:/', dir: 'c:/a/b/c', base: 'index.html', ext: '.html', name: 'index' &#125; path.join()作用： 追加路径 123path.join('c:/a/','b')//'c:\\a\\b' 数据解析获取 get 数据req.query属性可以获取（json方式） 获取 post 数据使用第三方模块 body-parser 安装 1npm i pody-parser -D 引入 1const bodyPaser = require('body-parser') 配置中间件 1server.use(bodyParser.urlencoded(&#123;extended: false&#125;)) 获取数据 12server.post('/a', (req, res)=&gt;&#123; console.log(req.body); 路由创建路由的基本步骤 创建路由 1let userRouter = express.Router() 设置父级路由 12// 所有和 /user 有关的路由都由 userRouter 处理server.use('/user', userRouter) 设置子路由 12345678//处理 /user/ 的路由userRouter.get('/', (req, res) =&gt; &#123; res.send('首页')&#125;)//处理 /user/a 的路由userRouter.get('/a', (req, res) =&gt; &#123; res.send('aaaaaaa')&#125;) 路由模块化将子路由封装到一个模块 user.js 中， 并用 module.exports 导出 1234567891011const express = require('express')let router = express.Router()router.get('/', (req, res) =&gt; &#123; res.send('首页')&#125;)router.get('/a', (req, res) =&gt; &#123; res.send('aaaaaaa')&#125;)module.exports = router 修改父级路由，只需要请求该模块即可 1server.use('/user',require('./routes/user.js')) 其他状态码返回1res.sendStatus(404) //返回404 状态码 相当于原生的 123res.writeHeader(404)res.write('Not Fond')res.end() 重定向1res.redirect('http://www.baidu.com') 相当于原生的 123res.setHeader('location','http://www.baidu.com')res.writhHeader(301)res.end() 开放静态资源开放www目录下面的静态资源可以被用户访问 1server.use(experss.static('www/'))]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F03%2F29%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas 画布 标签必须在行内设置 width 和 height，不能在其他地方添加。 1&lt;canvas width="300" height="100"&gt;&lt;/canvas&gt; 操作画布基础步骤 创建画布对象，并设置宽高 1&lt;canvas width="300" height="100" id="c1"&gt;&lt;/canvas&gt; 获取画布对象 1let oC = document.getElementById('c1') 获取上下文 1let gd = oC.getContext('2d') 设置起始坐标 1gd.moveTo(100,100) 设置移动终点坐标 1gd.lineTo(200,200) 设置线条颜色 1gd.strokeStyle = 'red' 绘画 1gd.stroke() 重新开始绘画路径（防止干扰上一条路径） 1gd.beginPath() 画布常用方法 moveTo(x, y) ： 设置起始坐标 lineTo(x, y)：设置终点坐标 stroke()：绘画（描边） fill()：填充 beginPath()：开始新路径，清除之前路径设置 closePath()：闭合当前路径 常见图像矩形 rect(x坐标，y坐标，宽，高) , 路径操作，需要描边才能生成图形 1234gd.beginPath()gd.rect(300,300,100,200)gd.strokeStyle = 'pink'gd.stroke() stokeRect(x坐标，y坐标，宽，高) , 图形操作，直接生成图形 123gd.beginPath()gd.strokeStyle = 'pink'gd.strokeRect(300,300,100,200) fillRect(x坐标，y坐标，宽，高) , 图形操作，直接生成图形 123gd.beginPath()gd.fillStyle = 'pink'gd.fillRect(300,300,100,200) clearRect(x坐标，y坐标，宽，高), 清除图形 弧（圆）arc(圆心的x 坐标， 圆心的y坐标，半径，起始角度，终止角度，旋转反向） 角度时以弧度为单位（Math.PI = 180度） 起点在圆心右侧一个半径的位置 最后一个参数默认为 false 默认为 逆时针 路径操作，需要描边才能显示 123456let oC = document.querySelector('canvas')let gb = oC.getContext('2d') gb.beginPath()gb.arc(300, 300, 200,0, Math.PI * 2)gb.stroke() canvas 的 transformrotate rotate 操作 必须放在 图形绘制完成之前 rotate 操作其实是整个画布都在旋转，并不是绘制的图形旋转 translate scale]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存和多进程]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%BC%93%E5%AD%98%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[缓存和多进程缓存http缓存消息第一次请求，无缓存，服务端（S) 向 客户端 （C) 发送的http响应头部有 last-modified: Tue, 26 Feb 2019 10:51:39 GMT 告诉客户端 请求资源最后的修改日期 第二次请求，有缓存C —&gt; S If-Modified-Since: Tue, 26 Feb 2019 10:51:39 GMT S—-&gt; C 304状态码 node 实现缓存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const http = require('http')const fs = require('fs')const url = require('url')http.createServer((req, res) =&gt; &#123; let &#123;pathname&#125; = url.parse(req.url) // console.log(pathname); // 获取文件修改时间 fs.stat(`www$&#123;pathname&#125;`, (err, stat) =&gt; &#123; if (err) &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125; else &#123; // 如果请求头中有 If-Modified-Since 说明不是第一次获取数据，并且在第一次获取的时候，服务器传给浏览器 Last-Modif 响应头 if (req.headers['if-modified-since']) &#123; let oDate = new Date(req.headers['if-modified-since']) let time_client = Math.floor(oDate.getTime() / 1000) let time_server = Math.floor(stat.mtime.getTime() / 1000) // 比较那个版本更新 if (time_client &lt; time_server) &#123; sendFileToClient() &#125; else &#123; res.writeHead(304) res.write('Not Modified') res.end() &#125; &#125;else&#123; sendFileToClient() &#125; function sendFileToClient () &#123; let rs = fs.createReadStream(`www$&#123;pathname&#125;`) /* 添加 http 响应头，并将文件的修改世界转换成 格林威治时间 */ res.setHeader('Last-Modified', stat.mtime.toGMTString()) rs.pipe(res) rs.on('error', err =&gt; &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125;) &#125; &#125; &#125;)&#125;).listen(8888, () =&gt; &#123; console.log('running...'); &#125;) 多进程多进程和多线程 多线程 性能高、复杂、编程复杂 多进程 性能略低、简单 nodeJs 默认为 单进程、单线程 但是 nodejs可以设置成多进程 多进程的优点：性能高，安全 进程 普通程序不能创建进程，只有系统进程才可以创建进程 进程是分裂出来的，但是只有主进程可以分裂能力 分裂出来的进程执行同一套代码 父子进程之间可以共享’句柄‘ node 的多进程12345678910111213141516171819202122232425262728const http = require('http')// 引入 cluster 多进程模块const cluster = require('cluster')// cpu 为几核 几个进程可以同时工作，所以需要引入系统模块const os = require('os')// 获取当前进程的信息模块const process = require('process')// 判断当前是否为主进程if (cluster.isMaster) &#123; for (let i = 0; i &lt; os.cpus().length; i++) &#123; cluster.fork() &#125; console.log('主进程');&#125; else &#123; let server = http.createServer((req, res) =&gt; &#123; console.log(process.pid); res.write('aaaa'); res.end(); &#125;); server.listen(8888); console.log('服务器开好了，在8888上'); &#125;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流与压缩]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B5%81%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[流作用：边读取，边转发，减少内存存储压力 分类 流方式 常见的流 读取流 req, fs.createReadStream 写入流 res, fs.createWriteStream 读写流 压缩，加密 流操作的基本过程12345678const fs = require('fs')//建立一个读取流，读取 1.txt 文件let rs = createReadStream('1.text')//建立写入流写的文件 命名为 2.txtlet ws = createWriteStream('2.txt')//对接rs.pipe（ws) 这样就可以将 1.txt 文件 一边读取，一边写入到 2.txt 文件中 注意：流是有方向的，只能从读取流入写入 流操作再node中的应用文件读取和写入的应用123456789101112131415const http = require('http')const fs = require('fs')let server = http.createServer((req, res) =&gt; &#123; let rs = fs.createReadStream(`www$&#123;req.url&#125;`) rs.pipe(res) rs.on('error', err =&gt; &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125;)&#125;)server.listen(8888) 双向流– 压缩文件1234567891011121314151617//引入压缩模块const zlib = require('zlib')const fs = require('fs')let rs = fs.createReadStream('jquery.js')let ws = fs.createWriteStream('jquery.js.gz')// 创建压缩对象let gz = zlib.createGzip()// 双向流绑定rs.pipe(gz).pipe(ws)ws.on('finish', () =&gt; &#123; console.log('成功'); &#125;) 综合–将文件用node 压缩然后返回给浏览器12345678910111213141516171819const http = require('http')const fs = require('fs')const zlib = require('zlib')let server = http.createServer((req, res) =&gt; &#123; let rs = fs.createReadStream(`www$&#123;req.url&#125;`) res.setHeader('content-encoding', 'gzip') let gz = zlib.createGzip() rs.pipe(gz).pipe(res) rs.on('error', () =&gt; &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125;)&#125;)server.listen(8888) 注意：因为返回给浏览器的是压缩文件，所以应该设置响应头为 1res.setHeader(&apos;content-encoding&apos;, &apos;gzip&apos;) 否则浏览器不会解析压缩文件，而回将其下载]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[概述继承： 继承是类(class) 与(class) 之间的关系（父级别和子级别的关系），js 中没有类，但可以通过构造函数模拟类，然后通过原型来实现继承。 继承也是为了数据共享。 原型的作用： 共享数据，节省内存空间 实现继承 原型继承通过改变原型链实现继承 缺陷： 在原型链改变的时候会进行赋值 12345678910111213141516171819202122232425262728function Animal(name, weight) &#123; this.name = name this.weight = weight &#125; Animal.prototype.eat = function() &#123; console.log('吃'); &#125; function Dog(color) &#123; this.color = color &#125; Dog.prototype = new Animal('哮天犬', '50kg') Dog.prototype.bite = function () &#123; console.log(`$&#123;this.name&#125;咬人`); &#125; function ErHa(gender) &#123; this.gender = gender; &#125; ErHa.prototype = new Dog('黑白色') ErHa.prototype.play = function () &#123; console.log(`$&#123;this.name&#125;体重为$&#123;this.weight&#125;性别为：$&#123;this.gender&#125;颜色为 $&#123;this.color&#125;`); &#125; var erHa = new ErHa('母') erHa.eat() erHa.bite() erHa.play() 借用构造函数实现继承方法：通过构造函数名.call(当前对象，属性1，属性2) 解决了属性的继承，并且只不重复 缺陷： 父级别的累中的方法不能继承 如: 12345678910111213141516171819202122232425262728function Person(name, age, gender, weight) &#123; this.name = name; this.age = age this.gender = gender this.weight = weight &#125; Person.prototype.sayHi = function () &#123; console.log('hello'); &#125; function Student(name, age, gender, weight, score) &#123; // 借用构造函数 Person.call(this,name, age, gender, weight) this.score = score &#125; var stu1 = new Student('小明', 10, '男', '30kg', 100) console.log(stu1.name, stu1.age, stu1.gender, stu1.weight,stu1.score); //小明 10 男 30kg 100 stu1.sayHi() //报错 var stu2 = new Student('小红', 12, '女', '30kg', 80) console.log(stu2.name, stu2.age, stu2.gender, stu2.weight,stu2.score); //小红 12 女 30kg 80 var stu3 = new Student('小刚', 10, '男', '20kg', 110) console.log(stu3.name, stu3.age, stu3.gender, stu3.weight,stu3.score); //小刚 10 男 20kg 110 上面的 stu1 、stu2、stu3 都继承了 Persong 的属性，但没有继承方法 组合继承组合继承 = 原型继承 + 借用构造函数继承 通过原型继承方法； 通过借用构造函数继承属性 1234567891011121314151617181920212223242526272829function Person(name, age, gender) &#123; this.name = name this.age = age this.gender = gender &#125; Person.prototype.sayHi = function () &#123; console.log('hello'); &#125; function Student(name, age, gender, score) &#123; //借用构造函数 Person.call(this, name, age, gender) this.score = score &#125; // 改变原型链指向 Student.prototype = new Person()//不用传参 Student.prototype.eat = function () &#123; console.log('吃吃'); &#125; var stu = new Student('小明', 18, '男', 100) console.log(stu.name, stu.age, stu.gender, stu.score);//小明 18 男 100 stu.eat() //吃吃 stu.sayHi()//hellovar stu2 = new Student('小红', 12, '女', 100)console.log(stu2.name, stu2.age, stu2.gender, stu2.score);//小红 12 女 100stu2.eat() //吃吃stu2.sayHi()//hello 拷贝继承把一个对象的属性或者方法直接拷贝到另一个对象中 拷贝一个对象 12345678910111213var obj1 = &#123; name: '小明', age: 13, sleep: function () &#123; console.log('睡觉'); &#125; &#125; // var obj2 = obj1;(只拷贝了对象的地址，没有拷贝内容) //手动拷贝 var obj2 = &#123;&#125; for(var key in obj1) &#123; obj2[key] = obj1[key] &#125; 用拷贝实现继承 1234567891011function Person() &#123;&#125; Person.prototype.age = 10; Person.prototype.gender = '男' Person.prototype.play = function () &#123; console.log('玩'); &#125; var obj = &#123;&#125; for(var key in Person.prototype) &#123; obj[key] = Person.prototype[key] &#125; Person 的构造函数中有的 prototype 本来就是一个对象，age、gender、play 都是该对象的属性或方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型及原型链]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型及原型链new 的作用 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 选自： 《JavaScript高级程序设计（第三版）》P145 原型的作用原型对象和原型原型对象 每一个构造函数都有原型对象 prototype 属性 原型 每一个实例对象都有一个原型 __proto__ 属性 共享内存，节省内存空间案例一 没有使用原型 1234567891011121314//构造函数function Person(name, age) &#123; this.name = name this.age = age this.sayHi = function() &#123; console.log(`我叫$&#123;this.name&#125;, 我的年龄是$&#123;this.age&#125;`); &#125; &#125; //实例对象 var xiaoming = new Person('小明', 20) var xiaohong = new Person('小红', 15) xiaoming.sayHi() //我叫小明, 我的年龄是20 xiaohong.sayHi() //我叫小红, 我的年龄是15 console.log(xiaoming.sayHi === xiaohong.sayHi) //false 当执行 最后一句时结果为 false 说明所执行的函数不是同一个函数，并没有数据共享 原因：当 new 的时候 会把这个 sayHi 方法添加到实例对象申请的空间中，所以有多少实例对象就有多少 sayHi 方法 案例二 使用原型 1234567891011121314function Person(name, age) &#123; this.name = name this.age = age &#125; Person.prototype.sayHi = function () &#123; console.log(`我叫$&#123;this.name&#125;, 我的年龄是$&#123;this.age&#125;`); &#125; var xiaoming = new Person('小明', 20) var xiaohong = new Person('小红', 15) xiaoming.sayHi() //我叫小明, 我的年龄是20 xiaohong.sayHi() //我叫小红, 我的年龄是15 console.log(xiaoming.sayHi === xiaohong.sayHi);//true console.log(xiaohong.__proto__ === Person.prototype);//true 此时执行最后一句话时，结果为 true 说明执行的时同一个函数，实现了数据共享 原因： 实例对象的原型 __proto__ 和 构造函数的原型对象 prototype 是相同的（__proto__指向 prototype） 实例对象可以访问构造函数的原型（prototype） 原型链原型链指的是 实例对象 和 原型对象（prototype）之间的关系，这种关系是通过原型（__proto__)联系的 原型链的改变案例 12345678910111213141516171819// 人的构造函数 function Person(age) &#123; this.age = age &#125; // 人的原型对象的方法 Person.prototype.eat = function () &#123; console.log('人的吃方法'); &#125; // 狗的构造函数 function Dog() &#123;&#125; // 狗的原型对象的方法 Dog.prototype.sayHi = function () &#123; console.log('汪汪'); &#125; Dog.prototype = new Person(20) var bigDog = new Dog() bigDog.eat() //人的吃方法 bigDog.sayHi() //报错 分析： 1Dog.prototype = new Person(20) Dog 的原型对象的 替换成 new Person 这个实例对象 上面的代码 使 Dog 的原型对象指向了 new Person（）的原型，同时 又因为 Dog 的实例对象 bigDog 的原型（__proto__)指向的是 Dog 的原型对象（prototype），所以也就跟着改变了其指向，指向了new Pers（）的原型 总结 实例对象的原型__proto__指向的是该对象所在的构造函数的原型对象 构造函数的原型对象（prototype）指向如果改变，实例对象的原型__proto__也会发生改变 原型链的最终指向 实例对象中有__proto__原型 构造函数中有 prototype 原型对象 原型对象 prototype 中应该也有 __proto__ 原型，指向什么地方？ 1234567891011function Person() &#123; &#125; Person.prototype.eat = function () &#123; console.log('人的吃'); &#125; // 实例对象 var per = new Person() console.log(per.__proto__ === Person.prototype); //true console.log(per.__proto__.__proto__ === Person.prototype.__proto__); //true console.log(Person.prototype.__proto__ === Object.prototype); // true console.log(Object.prototype.__proto__); //null 分析 Object 是一个构造函数，有自己的原型对象（prototype） 每一个原型对象都有自己的原型__proto__， Object 的原型对象也不例外 构造函数的原型对象的原型指向 Object 的原型对象（上面的倒数第二句可知） Object 的原型对象的原型为null（上面的倒数第一句可知） 原型指向改变如何添加方法和访问原型对象改变前添加的方法，会在原型改变后失去，所以如果原型对象改变，应该先改变原型对象，再添加方法否则会出现原型链的改变中最后一句报错]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax的封装]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[数据通信常见的通信方式 通信方式 特点 表单 最基本，最简单 Ajax 不用全页面刷新，可跨域 jsonp 跨越，不安全 Websocket 高性能（快），双工通信，直接跨越 跨域：请求不同域名或端口或协议的资源 Ajax封装（仿jQuery）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Ajax (options) &#123; options = options || &#123;&#125; options.type = options.type || 'get'; options.data = options.data || &#123;&#125; options.dataType = options.dataType || 'text' let xhr = new XMLHttpRequest() //将 data里面以对象形式传入的值 解析成 a=b&amp;b=c 形式 var arr = [] for (const name in options.data) &#123; var str = `$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(options.data[name])&#125;` arr.push(str) &#125; let strData = arr.join('&amp;') if (options.type == 'post') &#123; xhr.open('POST',options.url, true) xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); xhr.send(strData) &#125;else &#123; xhr.open('GET', options.url + '?' + strData ,true) xhr.send() &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; let data = xhr.responseText switch (options.dataType) &#123; case 'json': if (window.JSON &amp;&amp; JSON.parse) &#123; data = JSON.parse(data) &#125;else&#123; data = eval('('+data+')') &#125; break; case 'xml': data = xhr.responseXML &#125; options.success &amp;&amp; options.success(data) &#125; &#125;else&#123; options.error &amp;&amp; options.error() &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2019%2F03%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据的表示原码、反码、补码、移码 数字 1 数字 -1 1 - 1 原码 0000 0001 1000 0001 1000 0010 反码 0000 0001 1111 1110 1111 1111 补码 0000 0001 1111 1111 0000 0000 移码 1000 0001 0111 1111 1000 0000 总结： 正数的 原码、反码、补码都是其二进制数 负数的 反码是除符号位，其他的都按位取反。 负数的补码是给他的反码 +1。 移码是补码的符号位取反。 表示范围 范围 原码 -（2^n-1^ - 1) ~ 2^n-1^ - 1 反码 -（2^n-1^ - 1) ~ 2^n-1^ - 1 补码 - 2^n-1^ ~ 2^n-1^ - 1 因为 0 的补码的正负都相同，所以范围比原码和反码大 1 浮点数表示N = M * R^e^ 位数：M 基数：R 指数：e CPU 的结构CPU由 运算器和 控制器组成 运算器 算术逻辑单元ALU 累加寄存器 AC 数据缓冲寄存器 DR 状态条件寄存器 PSW 控制器 程序计数器PC 指令寄存器 IR 指令译码器 时序部件 计算机体系结构的分类 – Flynn 体系结构类型 结构 关键特性 代表 单指令流单数据流SISD 控制部分：一个 处理器：一个 主存储模块： 一个 但处理系统 单指令流多数据流SIMD 控制部分：一个 处理器：多个 主存储模块： 多个 各种处理器以异步形式执行同一天指令 并列处理机，阵列处理机，超级向量处理机 多指令流单数据流MISD 控制部分：多个 处理器：一个 主存储模块： 多个 不存在 目前不存在 多指令流多数据流MIMD 控制部分：多个 处理器：多个 主存储模块： 多个 能够实现作业、任务、指令等各级全面并行 多处理机系统，多计算机 CISC 与 RISC 指令系统类型 指令 寻址方式 实现方式 其他 CISC（复杂） 数量多，使用频率差别大可变长格式 支持多种 微程序控制技术（微码） 研制周期长 RISC（精简） 数量少，使用频率接近，定长格式，大部分为单调指令，操作寄存器，只有Load/Store操作内存 支持方式少 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 优化编译，有效支持高级语言 流水线 流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术,各种部件同时处理是针对不同指令而言的,他们可同时为多条指令的不同部分进行工作,以提高各部件的利用率和指令的平均执行速度. 流水线的时间计算 流水线的周期为执行时间最长的一段 n条指令执行的理论时间 一条指令执行的时间（每一部分的时间和） + （指令数 - 1）* 流水线周期 n条指令执行的实践时间 流水线周期 * （指令的部分数 + 指令数 - 1） 在实践计算的时候，将第一条指令执行的时间看作周期 * 指令部分数 考试以理论结果优先 例题： 若指令流水线把一条指令分为取址、分析、执行三部分，且三部分的时间分别为：2ns、2ns、1ns、那么流水线的周期是多少？100条指令全部执行完需要多少时间？ 解答： 周期为 2ns， 理论执行时间 （2 +2 + 1) + (100 - 1) * 2 = 203ns 实践执行时间 （3 + 100 - 1） * 2 = 204ns 流水线的吞吐率计算 流水线的吞吐率（TP) 是指单位时间内流水线所完成的任务数量或输出的结果数量。 TP = 指令条数 / 流水线执行时间 流水线最大吞吐率为 ：1 / 周期 流水线的加速比定义： 完成同一任务，不使用流水线的时间与使用流水线的时间之比 s = 不使用流水线的时间 / 使用流水线的时间 存储层次化的存储结构从外存、内存、cache、寄存器，速度越来越高，容量越来越小。 CacheCache的功能：提高 CPU 数据输入输出的速率，突破 CPU 与存储系统间数据传送带宽限制。 Cache 是计算机存储系统中访问最快的层次 使用 Cache 改善系统性能的依据是程序的局部性原理 使用 Cache + 主存储器的系统的平均周期t = h * t1 + (1-h) * t2 h ：CPU对 Cache 的访问命中率， t1：Cache 的周期时间 t2：主存储器的周期时间 局部性原理 时间局部性 对刚刚访问的程序再进行访问，如循环体程序，这时就将这些都放入 Cache 中 空间局部性 对相邻的地址依次访问，如变量数组，也会将其放入 Cache 中 工作集理论：工作集是进程运行时被频繁访问的页码集合 主存分类 只读存储器（ROM） 断电存储内容不消失 随机存储器（RAM） 断电存储内容消失 编址例题： 内存地址从AC000H到C7FFFH,共有（）KB个地址单元，如果该内存地址按字（16bit）编址，由28块芯片构成。已知构成此内存的芯片每片有16KB个存储单元，则该芯片每个存储单元存储（）位 解答： 将内存大地址减去小地址再加1就是内存地址，即C7FFFH-AC000H+1=1C000H(给7加的是16，因为是16进制)， 十六进制（1C000）16=2^16+2^15+2^14=64K+32K+16K=112K. 注意此处按字编址。需要构成的内存为112K16b,使用28块芯片构成该内存，则每个芯片的容量应为4K16B。已知构成此内存的芯片每片有16K个存储单元，因此该芯片每个存储单元存储4位二进制 磁盘结构与参数存取时间 = 寻道时间 + 等待时间 寻道时间： 磁头移动到磁道所需要的时间 等待时间： 等待要读写的扇区转动到磁头下面的时间 总线 内部总线（芯片级别） 系统总线（线路板级别） 数据总线 地址总线 控制总线 外部总线（外设级别） 可靠性分析串联系统和并联系统串联可靠度：R = R1 R2 R3 … Rn 失效度： S = S1 + S2 + S3 + … + Sn 并联可靠度： R = 1 - (1 - R1) (1 - R2) … * (1 - Rn) 失效度：S = 1 - R 差错控制循环校验码 CRC 可以检错，不能纠错 重点 海明码 既可以检错，又可以纠错 重点]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端轮播图]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[要求 自动轮播且无缝 点要随着图片的轮播而同步改变 图片的轮播可以随手指的滑动而改变 手指滑动距离小于屏幕的 1/3 吸附回去 手指滑动距离大于屏幕的 1/3 切换下一张或上一张图片 html注意： 第一张图片之前重复最后一张，最后一种之后重复第一张 123456789101112131415161718192021222324&lt;div class="jd_banner"&gt; &lt;ul class="clearFix"&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l8.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l1.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l2.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l3.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l4.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l5.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l6.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l7.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l8.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l1.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li class="now"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114let banner = function () &#123; /* 获取元素 */ let banner = document.querySelector('.jd_banner') let width = banner.offsetWidth let imageBox = banner.querySelector('ul:first-child') let pointBox = banner.querySelector('ul:last-child') let points = pointBox.querySelectorAll('li') let addTransition = function () &#123; imageBox.style.transition = 'all 0.2s' imageBox.style.webkitTransition = 'all 0.2s' &#125; let removeTransition = function () &#123; imageBox.style.transition = 'none' imageBox.style.webkitTransition = 'none' &#125; let setTranslateX = function (translateX) &#123; imageBox.style.transform = 'translateX(' + translateX + 'px)' imageBox.style.webkitTransform = 'translateX(' + translateX + 'px)' &#125; let index = 1 let timer = setInterval(()=&gt;&#123; index++ addTransition() setTranslateX(-index * width) &#125;, 1000); /* 判断是否要移动到第一张 */ imageBox.addEventListener('transitionend', ()=&gt;&#123; if (index &gt;= 9) &#123; index = 1 /* 清除过渡 */ removeTransition() /* 移动 */ setTranslateX(-index * width) &#125; else if (index &lt;= 0) &#123; index = 8; removeTransition() setTranslateX(-index * width) &#125; setPoint() &#125;) /* 焦点移动方法 */ let setPoint = function () &#123; // 伪数组转换成真数组 let arr = Array.from(points) arr.forEach((item)=&gt;&#123; item.classList.remove('now') &#125;) points[index - 1].classList.add('now') &#125; /* 手指触摸移动事件 ---》元素随手中移动距离的改变而改变 */ let startX = 0; let distanceX = 0 let isMove = false imageBox.addEventListener('touchstart', (e)=&gt;&#123; // 清除定时器 clearInterval(timer) // 记录触摸点的 X 坐标 startX = e.touches[0].clientX; &#125;) imageBox.addEventListener('touchmove', (e)=&gt;&#123; // 记录滑动中的 X 坐标 let moveX = e.touches[0].clientX // 计算滑动距离 distanceX = moveX - startX; // 元素移动的距离 = 当前的位置 + 滑动的距离 let translateX = -index * width + distanceX // 元素在跟随手指移动是不需要原来的动画过渡 removeTransition() setTranslateX(translateX) isMove = true &#125;) imageBox.addEventListener('touchend', (e) =&gt; &#123; /* 用滑动的距离是否小于 1/3 来判断是否切换图片 */ if (isMove) &#123; if (Math.abs(distanceX) &lt; width / 3) &#123; addTransition() setTranslateX(-index * width) &#125; else &#123; // 右滑动，切换上一张 if (distanceX &gt; 0) &#123; index-- &#125; else &#123; index++ &#125; addTransition() setTranslateX(-index * width) &#125; &#125; /* 重置参数 */ startX = 0 distanceX = 0 isMove = false /* 开启定时器 */ clearInterval(timer) timer = setInterval(() =&gt; &#123; index++ addTransition() setTranslateX(-index * width) &#125;, 1000); &#125;)&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap 常见组件]]></title>
    <url>%2F2019%2F03%2F06%2Fbootstrap%E5%B8%B8%E8%A7%81%E7%BB%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[栅格系统.container 容器响应式布局容器 用法： 123&lt;div class= 'container'&gt; 响应式内容&lt;/div&gt; .container 容器默认有 15px 的左右内间距 栅格系统栅格系统就是行列布局 行： row.row 可以填充 .container 的 15px 的内边距，因为设置了 margin-left，margin-right = 15px 用来填充 .container 容器的内边距 列 : col使用样式 1col-参数1-参数2 参数1： 参数值 作用范围 lg 大屏以上设备生效 md 中屏以上设备生效 sm 小屏以上设备生效 xs 超小屏以上设备生效 参数2： 每一行的等分数，默认 12 等分，是几就占几份（取值 1–12） 列子 12345678910111213141516171819202122232425&lt;style&gt; .container&#123; height: 100px; background: hotpink; &#125; .row&#123; height: 50px; background: pink; &#125; .row &gt; div&#123; height: 25px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-3"&gt;&lt;/div&gt; &lt;div class="col-md-4"&gt;&lt;/div&gt; &lt;div class="col-md-5"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 列偏移col-参数1-offset-参数2 栅格向右偏移 多少份（ 参数和上面相同） 123&lt;div class = 'col-xm-6 col-xm-offset-1'&gt; &lt;/div&gt; 列排序 col-参数1-push-参数2 向右移动 col-参数1-pull-参数2 向左移动 导航条（navBar) 组件因为导航条中用到了 Collapse 组件 所以先要了解 collapsed 组件 Collapse 组件Collapse 组件作用时 控制其他元素的展开或隐藏 data-toggle=”collapse” 组件类型申明 为 collapse （坍塌） data-target=”.box” 控制目标为 .box的选择器的元素 在 a 标签中 data-target 可以 直接用 href 替换 1234567891011&lt;button data-toggle="collapse" data-target=".box" aria-expander='false'&gt;切换&lt;/button&gt; &lt;a href=".box" data-toggle="collapse"&gt;切换&lt;/a&gt; &lt;div class="box"&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; &lt;/div&gt; navBar组件分析 aria-expanded=”false” 用于屏幕阅读器使用，（提示有一个没有展开的区域） class=”sr-only” 仅用于屏幕阅读器阅读，里面的内不会显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;nav class="navbar navbar-default"&gt; &lt;!-- 采用流式布局 --&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;!-- 以下为三个字体图标，共同组成了一个显示按钮 --&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 这是商标区域--&gt; &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!--以下的 链接、表单、其他内容被上面的按钮切换 --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 轮播bootstrap 轮播图分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- carousel 轮播图的模块 slide是否加上滑动效果 --&gt;&lt;!-- data-ride="carousel" 初始化轮播图属性--&gt;&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- 点盒子 --&gt; &lt;ol class="carousel-indicators"&gt; &lt;!-- data-target="#carousel-example-generic" 控制目标轮播图 data-slide-to="0" 控制的是轮播图当中的第几张 （索引） class="active" 当前选中的点 --&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- 图片盒子 --&gt; &lt;!-- role="listbox" 提供给屏幕阅读器使用 --&gt; &lt;div class="carousel-inner"&gt; &lt;!--需要轮播的容器--&gt; &lt;div class="item active"&gt; &lt;!--图片--&gt; &lt;img src="..." alt="..."&gt; &lt;!--说明--&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- 上一张下一张按钮 --&gt; &lt;!-- data-slide="prev" data-slide="next" href="#carousel-example-generic" 控制目标轮播图 --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 缺点：在移动端图片显示太过于 扁长 ，显示有缺陷，图片大小修改会造成显示问题 修改pc端显示效果将 img 标签的图片修改成 background 来显示，这样可以控制图片大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;style&gt; .pcimg_box&#123; height: 400px; width: 100%; display: block; background-size: cover; background-position: center; background-repeat: no-repeat; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;!-- 指示器（焦点） --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="3"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_01_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_02_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_03_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_04_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 需要将背景图片写在行内样式中，方便后端渲染 标签页12345678910111213141516&lt;!-- 页签 --&gt; &lt;ul class="nav nav-tabs" role="tablist"&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#home" aria-controls="home" role="tab" data-toggle="tab"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#profile" aria-controls="profile" role="tab" data-toggle="tab"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#messages" aria-controls="messages" role="tab" data-toggle="tab"&gt;Messages&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#settings" aria-controls="settings" role="tab" data-toggle="tab"&gt;Settings&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- Tab panes --&gt; &lt;div class="tab-content"&gt; &lt;div role="tabpanel" class="tab-pane active" id="home"&gt;1&lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="profile"&gt;2&lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="messages"&gt;3&lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="settings"&gt;4&lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
        <tag>前端库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的获取和转换]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据的获取和转换获取页面 url 通过问号传参传递的样式为： 1http://localhost:3000/m/searchList.html?key=1&amp;name=10 获取： 1234567891011121314var getParamsByUrl = function () &#123; var params = &#123;&#125; var search = location.search //"?key=1&amp;name=10" if (search) &#123; search = search.replace('?', '') //"key=1&amp;name=10" var arr = search.split('&amp;') //["key=1", "name=10"] arr.forEach(function (item, i) &#123; var itemArr = item.split('=') //["key", "1"] ["name", "10"] params[itemArr[0]] = itemArr[1] //&#123;key: "1", name: "10"&#125; &#125;) &#125; return params; &#125;var params = getParamsByUrl() node 获取 get 和 post 参数获取 get 参数直接从url 中获取 使用 req.rul 1234let server = http.createServer((req, res) =&gt; &#123; console.log(req.url);// /data.js?username=se&amp;pwd=d res.end()&#125;) 以对象形式获取 引入 url 核心模块 1let url = require('rul') 给 url使用parse 方法解析 req.url 1234let server = http.createServer((req, res) =&gt; &#123; let obj = url.parse(req.url) console.log(obj); res.end() 解析结果为 12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?username=se&amp;pwd=f', query: 'username=se&amp;pwd=f', pathname: '/data.js', path: '/data.js?username=se&amp;pwd=f', href: '/data.js?username=se&amp;pwd=f' &#125; 此时的 query 属性还是 字符串形式，如果给 parse 方法传入第二个参数：true，则结果为 12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?username=se&amp;pwd=deee', query: [Object: null prototype] &#123; username: 'se', pwd: 'deee' &#125;, pathname: '/data.js', path: '/data.js?username=se&amp;pwd=deee', href: '/data.js?username=se&amp;pwd=deee' &#125; 这时的 query 属性值为一个对象 获取 post 提交参数post 提交的参数在请求体中，获取请求体是以分组报文的形式获取，所以 post 里面的参数不能直接一次性获取 12345678910111213141516171819const http = require('http')//解析传来的参数为 jsonconst queryString = require('querystring')let server = http.createServer((req, res) =&gt; &#123; let str = '' // 监听每一部分报文到达，将每一次的报文拼装 req.on('data', data=&gt; &#123; str +=data &#125;) //全部传输完毕 req.on('end', ()=&gt; &#123; let post = queryString.parse(str) console.log(str); // username=se&amp;pwd=fgd [Object: null prototype] &#123; username: 'se', pwd: 'fgd' &#125; res.end() &#125;)&#125;)server.listen(8888) 这种方式只可以获取普通编码数据，不能获取二进制文件，因为二进制转换成字符串，再转换回去格式会被破坏 url.parse 和queryString.parse 区别 url.parse()解析的是整个 url 如：/data.js?username=se&amp;pwd=f querystring.parse()解析的是 参数 如：username=se&amp;pwd=f 封装成都可以获取12345678910111213141516171819202122const http = require('http')const url = require('url')const querystring = require('querystring')let server = http.createServer((req, res) =&gt; &#123; // 获取get参数 let &#123;pathname, query&#125; = url.parse(req.url,true) // 获取post 参数 let str ='' req.on('data', data =&gt; &#123; str += data &#125;) req.on('end', () =&gt; &#123; let post = querystring.parse(str) console.log(pathname, query, post); &#125;) res.end() &#125;)server.listen(3000)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板引擎使用步骤]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[模板引擎渲染步骤 获取数据 定义模板 调用模板 返回 html 1. 用 jQuery 发送 get请求，获取数据123456789101112var getFirstCategoryData = function (callback) &#123; $.ajax(&#123; url: '/category/queryTopCategory', type: 'get', data: '', dataType: 'json', success: function (data) &#123; callback &amp;&amp; callback(data) &#125; &#125;);&#125; 后台返回的json数据 12345678&#123;total: 5, rows: Array(5)&#125;rows: Array(5)0: &#123;id: 1, categoryName: "运动馆", isDelete: 1&#125;1: &#123;id: 2, categoryName: "女士馆", isDelete: 1&#125;2: &#123;id: 3, categoryName: "男士馆", isDelete: 1&#125;3: &#123;id: 4, categoryName: "帆布馆", isDelete: 1&#125;4: &#123;id: 5, categoryName: "户外管", isDelete: 1&#125;length: 5 2. 定义模板12345&lt;script type="text/template" id="firstTemplate"&gt; &lt;% for(var i = 0; i &lt; rows.length; i++) &#123; %&gt; &lt;li class="&lt;%= i==0?'now':''%&gt;"&gt;&lt;a href="javascript:;" data-id = "&lt;%=rows[i].id%&gt;"&gt; &lt;%=rows[i].categoryName%&gt;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/script&gt; 3. 调用模板,进行渲染123getFirstCategoryData(function (data) &#123; $('.cate_left ul').html(template('firstTemplate',data)) &#125;) 4. 渲染结果1234567891011&lt;ul&gt; &lt;li class="now"&gt;&lt;a href="javascript:;" data-id="1"&gt;运动馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="2"&gt;女士馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="3"&gt;男士馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="4"&gt;帆布馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="5"&gt;户外馆&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端库</tag>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less常见语法]]></title>
    <url>%2F2019%2F03%2F03%2Fless%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Less安装less1npm i -g less less 文件编译成 css 文件手动编译 1lessc less文件.less 编译后的css文件.css vscode 自动编译 安装插件 Ease Less 变量申明变量 必须@ 前缀 : 相当于 等号 ，必须; 结束。 必须符合变量的命名规则。 1@mainColor: #ccc; 使用变量123a:hover&#123; color:@mainColor;&#125; 编译结果 123a:hover&#123; color:#ccc;&#125; 注意：less 文件开头 指定编码为 UTF-8 编码 1@charset "UTF-8" Mixin 混入类混入less 语法 12345678910.w50&#123; width: 50%;&#125;.f_left&#123; float: left;&#125;.w50-f_left&#123; .w50(); .f_left();&#125; 编译成 css 12345678910.w50 &#123; width: 50%;&#125;.f_left &#123; float: left;&#125;.w50-f_left &#123; width: 50%; float: left;&#125; 编译的 css 会出现混入前的类 函数混入less 语法 12345678910.w50()&#123; width: 50%;&#125;.f_left()&#123; float: left;&#125;.w50-f_left&#123; .w50(); .f_left()&#125; 编译成 css 。 1234.w50-f_left &#123; width: 50%; float: left;&#125; 编译后的 css 不会出现函数本体。 带参函数混入 定义了参数（没有默认值）调用的时候必须传参。 定义 默认值的方式和定义变量相同。 定义了参数（有默认值），调用的时候可以不用传参。 less 语法 12345678.f(@direction: left) &#123; float:@direction;&#125;.r_left&#123; .f(); .f(right)&#125; 编译的 css 1234.r_left &#123; float: left; float: right;&#125; 嵌套为了使 css 的层次更加清楚 ，less 可以像 html一样进行类似的嵌套写法 less语法 1234567891011121314.top_bar&#123; position: relative; img&#123; display: block; position: absolute; top: 0; left: 0; &#125; &amp;::after&#123; content: ""; display: block; &#125;&#125; 编译后的 css 12345678910.top_bar img &#123; display: block; position: absolute; top: 0; left: 0;&#125;.top_bar::after &#123; content: ""; display: block;&#125; 注意：伪类和伪元素等需要和前面的选择器紧挨使用的 需要用&amp;符号进行连接否则编译后会有空格。 Import（导入）less 可以进行模块化，最后可以用 import 进行导入组合 variables.less 的内容 123456789@mainColor:#ccc;@box: box;a:hover&#123; color: @mainColor;&#125;.@&#123;box&#125; &#123; color:@mainColor;&#125; 在 main.less 中导入 variables.less 1@import "variables"; 编译的 css 文件 123456a:hover &#123; color: #ccc;&#125;.box &#123; color: #ccc;&#125; 运算less 支持数字的简单运算 1234567@num:7;ul&#123; width: 100% * @num; li&#123; width: 100% / @num; &#125;&#125; 编译后的css 123456ul &#123; width: 700%;&#125;ul li &#123; width: 14.28571429%;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem+less适配]]></title>
    <url>%2F2019%2F03%2F03%2Frem-less%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[rem 和 emrem和 em都是相对单位 区别 em 是基于父容器的字体大小 rem 是基于根元素（也就是 html 元素）的字体大小 rem 适配常见的适配方案 名称 缺点 伸缩布局 元素只能宽度适配 流式布局 元素只能宽度适配 响应式布局 元素只能宽度适配 rem 布局 高度和宽度可以同时适配 rem 适配原理页面的尺寸都用 rem 作为单位，针对不同大小的页面只需要更改 基准值 html 的大小即可实现适配 rem 基准值的换算公式当前设备 rem 基准值 = 预设的基准值 / 设计稿的宽度 * 当前设备的宽度 当前的设备： 设备宽度为 640px ，当前的 div 为 640px 100px，预设基准为 100px ，所以div 大小可以转换为 6.4rem 1rem 适配的设备： 设备宽度为 320px ，div 的大小为 6.4rem * 1rem，要想div的尺寸实现适配，需要修改当前的 rem 基准值。 由上面的公式可以算出： 100 / 640 * 320 = 50px。 所以需要修改当前的 基准值为 50px less + rem 实现多种设备的适配根据 rem 的适配原理，可以知道是根据设备的宽度不同来改变 html 元素的字体大小来进行适配。所以如果根据当前设备宽度来改变 html 元素的字体大小呢？ 方式一：媒体查询 同时适配 640px 和 320px 的设备 1234567891011121314151617181920212223242526272829&lt;style&gt; @media (min-width:320px) &#123; html&#123; font-size: 50px; &#125; &#125; @media (min-width: 640px) &#123; html&#123; font-size: 100px; &#125; &#125; body&#123; margin: 0; padding: 0; &#125; header&#123; width: 100%; height: 1rem; line-height: 1rem; font-size: 0.32rem; text-align: center; background-color: green; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;购物车&lt;/header&gt;&lt;/body&gt; 随着设备的增多，媒体查询和基准值的计算会不方便同时也不好维护，所以可以通过 less 进行改进 方式二：less 定义存储变量的less 文件 var.less 123456789101112@charset "UTF-8";//变量// 通过 less 定义数组，存储主流设备的尺寸@adapterDeviceList:750px, 720px, 640px, 540px, 480px, 424px, 414px, 400px, 384px, 375px, 360px, 320px;// 设计稿尺寸@psdWidth: 750px;// 预设基准值@baseFontSize: 100px;// 设备的种类（数组的长度）// 通过内置函数 length来获取@len: length(@adapterDeviceList); 设置一个适配的less 文件 mixins.less 这个less文件通过递归来生成不同的媒体查询 less 没有循环语法 when （此处是函数的执行条件） 内置函数 extract（）用于获取数组里面的元素，传入两个参数，一个是数组名称，另一个时序号 下面的函数是倒着获取数组元素，生成媒体插叙的函数 123456789.adapterMixins(@index) when(@index &gt; 0) &#123; @media (min-width: extract(@adapterDeviceList, @index)) &#123; html&#123; font-size: @baseFontSize / @psdWidth * extract(@adapterDeviceList, @index); &#125; &#125; .adapterMixins(@index - 1);&#125;.adapterMixins(@len); 设置一个less 文件用于引入上面的less文件的 index.less 12@import "var.less";@import "mixins.less"; 编译 index.less 后引入到html文件即可]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>rem</tag>
        <tag>less</tag>
      </tags>
  </entry>
</search>
