<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[koa]]></title>
    <url>%2F2019%2F03%2F31%2Fkoa%2F</url>
    <content type="text"><![CDATA[koakoa 中所有的异步操作都需要用 async /await 安装 1npm i koa koa-static koa-better-body koa-convert koa-router -D koa-static 用于开放静态资源 koa-better-body 用于解析 post 提交数据 koa-convert 用于兼容中间件 koa-router 用于路由 koa 入门 引入模块 使用 监听端口 1234const koa = require('koa')let server = new koa()server.listen(8888) 路由koa 对router 强依赖，不像 express 一样可以自带简单路由 express 中的简单路由 1234let server = expressserver.get('/', (req, res)=&gt;&#123; &#125;) 但是这个不能在 koa 中使用，要在 koa 中使用路由，必须 引入路由模块， 创建路由 配置中间件 123456789101112const koa = require('koa')const router = require('koa-router')let server = new koa()server.listen(8888)let router1 = router()server.use(router1.routes())router1.get('/', async(ctx, next) =&gt; &#123; &#125;) async 中的 ctx 对象 的重要属性 ctx. req 原生的 req 对象 ctx.request koa 封装的 req 对象 ctx.res 原生的 res 对象 ctx.response koa 封装的 res 对象 ctx.response 设置响应头 12//设置一个 a 的响应头， 值为 12ctx.response.set('a', 12) 设置返回内容 12//向浏览器返回jsonctx.response.body = &#123;a: 12, b: 25&#125; 设置状态码 1ctx.response.status = 403 ctx.request 获取请求头 1ctx.request.headers 开放静态文件， 返回文件开放 www 目录下的资源 123456789const koa = require('koa')const static = require('koa-static')const path = require('path')let server = new koa()server.listen(8888)// 路径转化成绝对路径server.use(static(path.resolve('./www'))) 如果 www 目录下面 有一个 1.html 我文件，则可以通过 http://localhost:8888/1.html请求 koa-static 存在问题 发送给浏览器的文件没有经过压缩 发送的文件不会缓存 解决方法 使用中间件 koa-static-cache 代替 koa-static 123456789const koa = require('koa')const staticCache = require('koa-static-cache')const path = require('path')let server = new koa()server.listen(8888)// 路径转化成绝对路径server.use(staticCache(path.resolve('./www'))) 数据处理获取 get 数据获取问号参数 1ctx.request.query 获取路由参数 1ctx.params 123456789101112131415const koa = require('koa')const router = require('koa-router')let server = new koa()server.listen(8888)let r1 = router()server.use(r1.routes())// 路由参数为 user，和 ager1.get('/:user/:age', async (ctx, next) =&gt; &#123; ctx.response.body = 'sadfasd' console.log(ctx.params); //&#123; user: '小明', age: '54' &#125; &#125;) 请求url：http://localhost:8888/小明/54 ， 获取 post 数据 引入第三方模块 koa-better-body，用来解析 post 提交的数据 引入 koa-convert ，用来 兼容 koa-better-body 在 koa2版本的使用 ctx.request.fields 可以获取 post 方式提交的 表单，文件信息 ctx.request.files 只能获取 post 方式提交的 文件信息 使用1234567891011121314151617181920212223242526const koa = require('koa')const betterBody = require('koa-better-body')const staticCache = require('koa-static-cache')const convert = require('koa-convert')const path = require('path')let server = new koa()server.listen(8888)// 开放静态资源server.use(staticCache(path.resolve('./www')))server.use(convert(betterBody(&#123; //保存提交的文件地址 uploadDir: path.resolve('./upload'), //是否保留上传文件的扩展名（一般不用保留） keepExtensions: true&#125;)))//不用路由，可以获取所有的提交server.use(async ctx =&gt; &#123; console.log(ctx.request.fields); console.log(ctx.request.files); &#125;) cookie&amp;sessioncookie 获取cookie 1ctx.cookies.get(cookie名字) 设置cookie 1ctx.cookes.set(cookie名字，值，option) session使用 第三方模块 koa- session 1const session = require('koa-session') 配置中间件 {}中填入session 的信息 1server.use(session(&#123;&#125;, server)) 使用 1ctx.session ejs 后端渲染安装 ejs 1const ejs = require('koa-ejs') 将模板文件创建在 template 目录下 名称为 template.html 使用 12345678910111213141516171819202122const koa = require('koa')const path = require('path')const ejs = require('koa-ejs')let server = new koa()server.listen(8888)ejs(server, &#123; //模板文件目录 root: path.resolve('template'), layout: false, //模板文件 扩展名 viewExt: 'html'&#125;)server.use(async ctx=&gt;&#123; //渲染文件 template，不用带扩展名，&#123;渲染数据&#125; await ctx.render('template', &#123; name: 'zhao', age: 20 &#125;)&#125;) MySQL引入中间件 1let db = require('mysql-pro') 优点: 事务管理（Transaction） 防止 SQL 注入 使用 1234567891011121314151617181920212223242526272829303132const koa = require('koa')const router = require('koa-router')const Mysql = require('mysql-pro')const db = new Mysql(&#123; mysql: &#123; host: 'localhost', port: '3306', user: 'root', password: '123456', database: 'test' &#125;&#125;)const server = new koa()server.listen(8888)let r1= router()server.use(r1.routes())r1.get('/user', async ctx=&gt; &#123; let id = ctx.query.id; // 开启事务 await db.startTransaction() //防止sql 注入 let data = await db.executeTransaction('SELECT * FROM user WHERE ID=?;',[id]) ctx.response.body = data //关闭事务 await db.stopTransaction()&#125;) 注意: 开启事务，对应着要关闭事务 为了防止 sql 注入，mysql-pro 要求将 需要的参数用 ? 代替，然后将参数用数组的形式放到语句后面。 事务（transaction）性质： A 原子性 事务内的事情，要么都发生，要么都不发生 C 持久性 只要事务提交，他的作用就是永久的 I 隔离性 各事务之间独立，不干扰 D 一致性 事务前后的状态一致]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express]]></title>
    <url>%2F2019%2F03%2F30%2Fexpress%2F</url>
    <content type="text"><![CDATA[express基本使用步骤123456789101112const experss = require('experss')let server = experss()server.listen(8888)server.get('/a', (req, res)=&gt;&#123; res.send('sadf') &#125;)//使用中间件 开放 www下面的静态资源server.use(experss.static('www/')) 中间件 插件 –补充框架的功能 类似于流水线 中间件的next()方法（流水线）12345678910111213141516171819const experss = require('experss')let server = experss()server.listen(8888)server.get('/a', (req, res, next)=&gt;&#123; res.send('sadf') console.log('sssssss'); next()&#125;)server.get('/a', (req, res, next) =&gt; &#123; console.log('dddddddddddd'); next()&#125;)server.use(experss.static('www/')) 添加了 next(), 程序会执行向下执行 路径path 模块中有 resolve() 方法 可以获取文件绝对路径 path.basename作用： 获取路径中的文件名 12345path.basename('c:a/b/c/d/index.js') 'index.js'path.basename('c:a/b/c/index.js', '.js') 'index' path.dirname作用： 获取文件目录 12path.dirname('c:a/b/c/index') c:a/b/c' path.extname作用： 获取文件扩展名 12path.extname('c:/a/b/c/index.js') '.js' path.isAbsolute作用: 判断是否为绝对路径 12345678path.isAbsolute('a/b/c/index') falsepath.isAbsolute('/a/b/c/index') truepath.isAbsolute('./a/b/c/index') false path.parse作用： 获取路径的所有信息 12345678path.parse('c:/a/b/c/index.html')//&#123; root: 'c:/', dir: 'c:/a/b/c', base: 'index.html', ext: '.html', name: 'index' &#125; path.join()作用： 追加路径 123path.join('c:/a/','b')//'c:\\a\\b' 数据解析获取 get 数据req.query属性可以获取（json方式） 获取 post 数据使用第三方模块 body-parser 安装 1npm i pody-parser -D 引入 1const bodyPaser = require('body-parser') 配置中间件 1server.use(bodyParser.urlencoded(&#123;extended: false&#125;)) 获取数据 12server.post('/a', (req, res)=&gt;&#123; console.log(req.body); 路由创建路由的基本步骤 创建路由 1let userRouter = express.Router() 设置父级路由 12// 所有和 /user 有关的路由都由 userRouter 处理server.use('/user', userRouter) 设置子路由 12345678//处理 /user/ 的路由userRouter.get('/', (req, res) =&gt; &#123; res.send('首页')&#125;)//处理 /user/a 的路由userRouter.get('/a', (req, res) =&gt; &#123; res.send('aaaaaaa')&#125;) 路由模块化将子路由封装到一个模块 user.js 中， 并用 module.exports 导出 1234567891011const express = require('express')let router = express.Router()router.get('/', (req, res) =&gt; &#123; res.send('首页')&#125;)router.get('/a', (req, res) =&gt; &#123; res.send('aaaaaaa')&#125;)module.exports = router 修改父级路由，只需要请求该模块即可 1server.use('/user',require('./routes/user.js')) 其他状态码返回1res.sendStatus(404) //返回404 状态码 相当于原生的 123res.writeHeader(404)res.write('Not Fond')res.end() 重定向1res.redirect('http://www.baidu.com') 相当于原生的 123res.setHeader('location','http://www.baidu.com')res.writhHeader(301)res.end() 开放静态资源开放www目录下面的静态资源可以被用户访问 1server.use(experss.static('www/'))]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F03%2F29%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas 画布 标签必须在行内设置 width 和 height，不能在其他地方添加。 1&lt;canvas width="300" height="100"&gt;&lt;/canvas&gt; 操作画布基础步骤 创建画布对象，并设置宽高 1&lt;canvas width="300" height="100" id="c1"&gt;&lt;/canvas&gt; 获取画布对象 1let oC = document.getElementById('c1') 获取上下文 1let gd = oC.getContext('2d') 设置起始坐标 1gd.moveTo(100,100) 设置移动终点坐标 1gd.lineTo(200,200) 设置线条颜色 1gd.strokeStyle = 'red' 绘画 1gd.stroke() 重新开始绘画路径（防止干扰上一条路径） 1gd.beginPath() 画布常用方法 moveTo(x, y) ： 设置起始坐标 lineTo(x, y)：设置终点坐标 stroke()：绘画（描边） fill()：填充 beginPath()：开始新路径，清除之前路径设置 closePath()：闭合当前路径 常见图像矩形 rect(x坐标，y坐标，宽，高) , 路径操作，需要描边才能生成图形 1234gd.beginPath()gd.rect(300,300,100,200)gd.strokeStyle = 'pink'gd.stroke() stokeRect(x坐标，y坐标，宽，高) , 图形操作，直接生成图形 123gd.beginPath()gd.strokeStyle = 'pink'gd.strokeRect(300,300,100,200) fillRect(x坐标，y坐标，宽，高) , 图形操作，直接生成图形 123gd.beginPath()gd.fillStyle = 'pink'gd.fillRect(300,300,100,200) clearRect(x坐标，y坐标，宽，高), 清除图形 弧（圆）arc(圆心的x 坐标， 圆心的y坐标，半径，起始角度，终止角度，旋转反向） 角度时以弧度为单位（Math.PI = 180度） 起点在圆心右侧一个半径的位置 最后一个参数默认为 false 默认为 逆时针 路径操作，需要描边才能显示 123456let oC = document.querySelector('canvas')let gb = oC.getContext('2d') gb.beginPath()gb.arc(300, 300, 200,0, Math.PI * 2)gb.stroke() canvas 的 transformrotate rotate 操作 必须放在 图形绘制完成之前 rotate 操作其实是整个画布都在旋转，并不是绘制的图形旋转 translate scale]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存和多进程]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%BC%93%E5%AD%98%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[缓存和多进程缓存http缓存消息第一次请求，无缓存，服务端（S) 向 客户端 （C) 发送的http响应头部有 last-modified: Tue, 26 Feb 2019 10:51:39 GMT 告诉客户端 请求资源最后的修改日期 第二次请求，有缓存C —&gt; S If-Modified-Since: Tue, 26 Feb 2019 10:51:39 GMT S—-&gt; C 304状态码 node 实现缓存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const http = require('http')const fs = require('fs')const url = require('url')http.createServer((req, res) =&gt; &#123; let &#123;pathname&#125; = url.parse(req.url) // console.log(pathname); // 获取文件修改时间 fs.stat(`www$&#123;pathname&#125;`, (err, stat) =&gt; &#123; if (err) &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125; else &#123; // 如果请求头中有 If-Modified-Since 说明不是第一次获取数据，并且在第一次获取的时候，服务器传给浏览器 Last-Modif 响应头 if (req.headers['if-modified-since']) &#123; let oDate = new Date(req.headers['if-modified-since']) let time_client = Math.floor(oDate.getTime() / 1000) let time_server = Math.floor(stat.mtime.getTime() / 1000) // 比较那个版本更新 if (time_client &lt; time_server) &#123; sendFileToClient() &#125; else &#123; res.writeHead(304) res.write('Not Modified') res.end() &#125; &#125;else&#123; sendFileToClient() &#125; function sendFileToClient () &#123; let rs = fs.createReadStream(`www$&#123;pathname&#125;`) /* 添加 http 响应头，并将文件的修改世界转换成 格林威治时间 */ res.setHeader('Last-Modified', stat.mtime.toGMTString()) rs.pipe(res) rs.on('error', err =&gt; &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125;) &#125; &#125; &#125;)&#125;).listen(8888, () =&gt; &#123; console.log('running...'); &#125;) 多进程多进程和多线程 多线程 性能高、复杂、编程复杂 多进程 性能略低、简单 nodeJs 默认为 单进程、单线程 但是 nodejs可以设置成多进程 多进程的优点：性能高，安全 进程 普通程序不能创建进程，只有系统进程才可以创建进程 进程是分裂出来的，但是只有主进程可以分裂能力 分裂出来的进程执行同一套代码 父子进程之间可以共享’句柄‘ node 的多进程12345678910111213141516171819202122232425262728const http = require('http')// 引入 cluster 多进程模块const cluster = require('cluster')// cpu 为几核 几个进程可以同时工作，所以需要引入系统模块const os = require('os')// 获取当前进程的信息模块const process = require('process')// 判断当前是否为主进程if (cluster.isMaster) &#123; for (let i = 0; i &lt; os.cpus().length; i++) &#123; cluster.fork() &#125; console.log('主进程');&#125; else &#123; let server = http.createServer((req, res) =&gt; &#123; console.log(process.pid); res.write('aaaa'); res.end(); &#125;); server.listen(8888); console.log('服务器开好了，在8888上'); &#125;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流与压缩]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B5%81%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[流作用：边读取，边转发，减少内存存储压力 分类 流方式 常见的流 读取流 req, fs.createReadStream 写入流 res, fs.createWriteStream 读写流 压缩，加密 流操作的基本过程12345678const fs = require('fs')//建立一个读取流，读取 1.txt 文件let rs = createReadStream('1.text')//建立写入流写的文件 命名为 2.txtlet ws = createWriteStream('2.txt')//对接rs.pipe（ws) 这样就可以将 1.txt 文件 一边读取，一边写入到 2.txt 文件中 注意：流是有方向的，只能从读取流入写入 流操作再node中的应用文件读取和写入的应用123456789101112131415const http = require('http')const fs = require('fs')let server = http.createServer((req, res) =&gt; &#123; let rs = fs.createReadStream(`www$&#123;req.url&#125;`) rs.pipe(res) rs.on('error', err =&gt; &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125;)&#125;)server.listen(8888) 双向流– 压缩文件1234567891011121314151617//引入压缩模块const zlib = require('zlib')const fs = require('fs')let rs = fs.createReadStream('jquery.js')let ws = fs.createWriteStream('jquery.js.gz')// 创建压缩对象let gz = zlib.createGzip()// 双向流绑定rs.pipe(gz).pipe(ws)ws.on('finish', () =&gt; &#123; console.log('成功'); &#125;) 综合–将文件用node 压缩然后返回给浏览器12345678910111213141516171819const http = require('http')const fs = require('fs')const zlib = require('zlib')let server = http.createServer((req, res) =&gt; &#123; let rs = fs.createReadStream(`www$&#123;req.url&#125;`) res.setHeader('content-encoding', 'gzip') let gz = zlib.createGzip() rs.pipe(gz).pipe(res) rs.on('error', () =&gt; &#123; res.writeHead(404) res.write('Not Fond') res.end() &#125;)&#125;)server.listen(8888) 注意：因为返回给浏览器的是压缩文件，所以应该设置响应头为 1res.setHeader(&apos;content-encoding&apos;, &apos;gzip&apos;) 否则浏览器不会解析压缩文件，而回将其下载]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[概述继承： 继承是类(class) 与(class) 之间的关系（父级别和子级别的关系），js 中没有类，但可以通过构造函数模拟类，然后通过原型来实现继承。 继承也是为了数据共享。 原型的作用： 共享数据，节省内存空间 实现继承 原型继承通过改变原型链实现继承 缺陷： 在原型链改变的时候会进行赋值 12345678910111213141516171819202122232425262728function Animal(name, weight) &#123; this.name = name this.weight = weight &#125; Animal.prototype.eat = function() &#123; console.log('吃'); &#125; function Dog(color) &#123; this.color = color &#125; Dog.prototype = new Animal('哮天犬', '50kg') Dog.prototype.bite = function () &#123; console.log(`$&#123;this.name&#125;咬人`); &#125; function ErHa(gender) &#123; this.gender = gender; &#125; ErHa.prototype = new Dog('黑白色') ErHa.prototype.play = function () &#123; console.log(`$&#123;this.name&#125;体重为$&#123;this.weight&#125;性别为：$&#123;this.gender&#125;颜色为 $&#123;this.color&#125;`); &#125; var erHa = new ErHa('母') erHa.eat() erHa.bite() erHa.play() 借用构造函数实现继承方法：通过构造函数名.call(当前对象，属性1，属性2) 解决了属性的继承，并且只不重复 缺陷： 父级别的累中的方法不能继承 如: 12345678910111213141516171819202122232425262728function Person(name, age, gender, weight) &#123; this.name = name; this.age = age this.gender = gender this.weight = weight &#125; Person.prototype.sayHi = function () &#123; console.log('hello'); &#125; function Student(name, age, gender, weight, score) &#123; // 借用构造函数 Person.call(this,name, age, gender, weight) this.score = score &#125; var stu1 = new Student('小明', 10, '男', '30kg', 100) console.log(stu1.name, stu1.age, stu1.gender, stu1.weight,stu1.score); //小明 10 男 30kg 100 stu1.sayHi() //报错 var stu2 = new Student('小红', 12, '女', '30kg', 80) console.log(stu2.name, stu2.age, stu2.gender, stu2.weight,stu2.score); //小红 12 女 30kg 80 var stu3 = new Student('小刚', 10, '男', '20kg', 110) console.log(stu3.name, stu3.age, stu3.gender, stu3.weight,stu3.score); //小刚 10 男 20kg 110 上面的 stu1 、stu2、stu3 都继承了 Persong 的属性，但没有继承方法 组合继承组合继承 = 原型继承 + 借用构造函数继承 通过原型继承方法； 通过借用构造函数继承属性 1234567891011121314151617181920212223242526272829function Person(name, age, gender) &#123; this.name = name this.age = age this.gender = gender &#125; Person.prototype.sayHi = function () &#123; console.log('hello'); &#125; function Student(name, age, gender, score) &#123; //借用构造函数 Person.call(this, name, age, gender) this.score = score &#125; // 改变原型链指向 Student.prototype = new Person()//不用传参 Student.prototype.eat = function () &#123; console.log('吃吃'); &#125; var stu = new Student('小明', 18, '男', 100) console.log(stu.name, stu.age, stu.gender, stu.score);//小明 18 男 100 stu.eat() //吃吃 stu.sayHi()//hellovar stu2 = new Student('小红', 12, '女', 100)console.log(stu2.name, stu2.age, stu2.gender, stu2.score);//小红 12 女 100stu2.eat() //吃吃stu2.sayHi()//hello 拷贝继承把一个对象的属性或者方法直接拷贝到另一个对象中 拷贝一个对象 12345678910111213var obj1 = &#123; name: '小明', age: 13, sleep: function () &#123; console.log('睡觉'); &#125; &#125; // var obj2 = obj1;(只拷贝了对象的地址，没有拷贝内容) //手动拷贝 var obj2 = &#123;&#125; for(var key in obj1) &#123; obj2[key] = obj1[key] &#125; 用拷贝实现继承 1234567891011function Person() &#123;&#125; Person.prototype.age = 10; Person.prototype.gender = '男' Person.prototype.play = function () &#123; console.log('玩'); &#125; var obj = &#123;&#125; for(var key in Person.prototype) &#123; obj[key] = Person.prototype[key] &#125; Person 的构造函数中有的 prototype 本来就是一个对象，age、gender、play 都是该对象的属性或方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原型，继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型及原型链]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型及原型链new 的作用 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 选自： 《JavaScript高级程序设计（第三版）》P145 原型的作用原型对象和原型原型对象 每一个构造函数都有原型对象 prototype 属性 原型 每一个实例对象都有一个原型 __proto__ 属性 共享内存，节省内存空间案例一 没有使用原型 1234567891011121314//构造函数function Person(name, age) &#123; this.name = name this.age = age this.sayHi = function() &#123; console.log(`我叫$&#123;this.name&#125;, 我的年龄是$&#123;this.age&#125;`); &#125; &#125; //实例对象 var xiaoming = new Person('小明', 20) var xiaohong = new Person('小红', 15) xiaoming.sayHi() //我叫小明, 我的年龄是20 xiaohong.sayHi() //我叫小红, 我的年龄是15 console.log(xiaoming.sayHi === xiaohong.sayHi) //false 当执行 最后一句时结果为 false 说明所执行的函数不是同一个函数，并没有数据共享 原因：当 new 的时候 会把这个 sayHi 方法添加到实例对象申请的空间中，所以有多少实例对象就有多少 sayHi 方法 案例二 使用原型 1234567891011121314function Person(name, age) &#123; this.name = name this.age = age &#125; Person.prototype.sayHi = function () &#123; console.log(`我叫$&#123;this.name&#125;, 我的年龄是$&#123;this.age&#125;`); &#125; var xiaoming = new Person('小明', 20) var xiaohong = new Person('小红', 15) xiaoming.sayHi() //我叫小明, 我的年龄是20 xiaohong.sayHi() //我叫小红, 我的年龄是15 console.log(xiaoming.sayHi === xiaohong.sayHi);//true console.log(xiaohong.__proto__ === Person.prototype);//true 此时执行最后一句话时，结果为 true 说明执行的时同一个函数，实现了数据共享 原因： 实例对象的原型 __proto__ 和 构造函数的原型对象 prototype 是相同的（__proto__指向 prototype） 实例对象可以访问构造函数的原型（prototype） 原型链原型链指的是 实例对象 和 原型对象（prototype）之间的关系，这种关系是通过原型（__proto__)联系的 原型链的改变案例 12345678910111213141516171819// 人的构造函数 function Person(age) &#123; this.age = age &#125; // 人的原型对象的方法 Person.prototype.eat = function () &#123; console.log('人的吃方法'); &#125; // 狗的构造函数 function Dog() &#123;&#125; // 狗的原型对象的方法 Dog.prototype.sayHi = function () &#123; console.log('汪汪'); &#125; Dog.prototype = new Person(20) var bigDog = new Dog() bigDog.eat() //人的吃方法 bigDog.sayHi() //报错 分析： 1Dog.prototype = new Person(20) Dog 的原型对象的 替换成 new Person 这个实例对象 上面的代码 使 Dog 的原型对象指向了 new Person（）的原型，同时 又因为 Dog 的实例对象 bigDog 的原型（__proto__)指向的是 Dog 的原型对象（prototype），所以也就跟着改变了其指向，指向了new Pers（）的原型 总结 实例对象的原型__proto__指向的是该对象所在的构造函数的原型对象 构造函数的原型对象（prototype）指向如果改变，实例对象的原型__proto__也会发生改变 原型链的最终指向 实例对象中有__proto__原型 构造函数中有 prototype 原型对象 原型对象 prototype 中应该也有 __proto__ 原型，指向什么地方？ 1234567891011function Person() &#123; &#125; Person.prototype.eat = function () &#123; console.log('人的吃'); &#125; // 实例对象 var per = new Person() console.log(per.__proto__ === Person.prototype); //true console.log(per.__proto__.__proto__ === Person.prototype.__proto__); //true console.log(Person.prototype.__proto__ === Object.prototype); // true console.log(Object.prototype.__proto__); //null 分析 Object 是一个构造函数，有自己的原型对象（prototype） 每一个原型对象都有自己的原型__proto__， Object 的原型对象也不例外 构造函数的原型对象的原型指向 Object 的原型对象（上面的倒数第二句可知） Object 的原型对象的原型为null（上面的倒数第一句可知） 原型指向改变如何添加方法和访问原型对象改变前添加的方法，会在原型改变后失去，所以如果原型对象改变，应该先改变原型对象，再添加方法否则会出现原型链的改变中最后一句报错]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据通信]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[数据通信常见的通信方式 通信方式 特点 表单 最基本，最简单 Ajax 不用全页面刷新，可跨域 jsonp 跨越，不安全 Websocket 高性能（快），双工通信，直接跨越 跨域：请求不同域名或端口或协议的资源 Ajax封装（仿jQuery）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Ajax (options) &#123; options = options || &#123;&#125; options.type = options.type || 'get'; options.data = options.data || &#123;&#125; options.dataType = options.dataType || 'text' let xhr = new XMLHttpRequest() //将 data里面以对象形式传入的值 解析成 a=b&amp;b=c 形式 var arr = [] for (const name in options.data) &#123; var str = `$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(options.data[name])&#125;` arr.push(str) &#125; let strData = arr.join('&amp;') if (options.type == 'post') &#123; xhr.open('POST',options.url, true) xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); xhr.send(strData) &#125;else &#123; xhr.open('GET', options.url + '?' + strData ,true) xhr.send() &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; let data = xhr.responseText switch (options.dataType) &#123; case 'json': if (window.JSON &amp;&amp; JSON.parse) &#123; data = JSON.parse(data) &#125;else&#123; data = eval('('+data+')') &#125; break; case 'xml': data = xhr.responseXML &#125; options.success &amp;&amp; options.success(data) &#125; &#125;else&#123; options.error &amp;&amp; options.error() &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2019%2F03%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据的表示原码、反码、补码、移码 数字 1 数字 -1 1 - 1 原码 0000 0001 1000 0001 1000 0010 反码 0000 0001 1111 1110 1111 1111 补码 0000 0001 1111 1111 0000 0000 移码 1000 0001 0111 1111 1000 0000 总结： 正数的 原码、反码、补码都是其二进制数 负数的 反码是除符号位，其他的都按位取反。 负数的补码是给他的反码 +1。 移码是补码的符号位取反。 表示范围 范围 原码 -（2^n-1^ - 1) ~ 2^n-1^ - 1 反码 -（2^n-1^ - 1) ~ 2^n-1^ - 1 补码 - 2^n-1^ ~ 2^n-1^ - 1 因为 0 的补码的正负都相同，所以范围比原码和反码大 1 浮点数表示N = M * R^e^ 位数：M 基数：R 指数：e CPU 的结构CPU由 运算器和 控制器组成 运算器 算术逻辑单元ALU 累加寄存器 AC 数据缓冲寄存器 DR 状态条件寄存器 PSW 控制器 程序计数器PC 指令寄存器 IR 指令译码器 时序部件 计算机体系结构的分类 – Flynn 体系结构类型 结构 关键特性 代表 单指令流单数据流SISD 控制部分：一个 处理器：一个 主存储模块： 一个 但处理系统 单指令流多数据流SIMD 控制部分：一个 处理器：多个 主存储模块： 多个 各种处理器以异步形式执行同一天指令 并列处理机，阵列处理机，超级向量处理机 多指令流单数据流MISD 控制部分：多个 处理器：一个 主存储模块： 多个 不存在 目前不存在 多指令流多数据流MIMD 控制部分：多个 处理器：多个 主存储模块： 多个 能够实现作业、任务、指令等各级全面并行 多处理机系统，多计算机 CISC 与 RISC 指令系统类型 指令 寻址方式 实现方式 其他 CISC（复杂） 数量多，使用频率差别大可变长格式 支持多种 微程序控制技术（微码） 研制周期长 RISC（精简） 数量少，使用频率接近，定长格式，大部分为单调指令，操作寄存器，只有Load/Store操作内存 支持方式少 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 优化编译，有效支持高级语言 流水线 流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术,各种部件同时处理是针对不同指令而言的,他们可同时为多条指令的不同部分进行工作,以提高各部件的利用率和指令的平均执行速度. 流水线的时间计算 流水线的周期为执行时间最长的一段 n条指令执行的理论时间 一条指令执行的时间（每一部分的时间和） + （指令数 - 1）* 流水线周期 n条指令执行的实践时间 流水线周期 * （指令的部分数 + 指令数 - 1） 在实践计算的时候，将第一条指令执行的时间看作周期 * 指令部分数 考试以理论结果优先 例题： 若指令流水线把一条指令分为取址、分析、执行三部分，且三部分的时间分别为：2ns、2ns、1ns、那么流水线的周期是多少？100条指令全部执行完需要多少时间？ 解答： 周期为 2ns， 理论执行时间 （2 +2 + 1) + (100 - 1) * 2 = 203ns 实践执行时间 （3 + 100 - 1） * 2 = 204ns 流水线的吞吐率计算 流水线的吞吐率（TP) 是指单位时间内流水线所完成的任务数量或输出的结果数量。 TP = 指令条数 / 流水线执行时间 流水线最大吞吐率为 ：1 / 周期 流水线的加速比定义： 完成同一任务，不使用流水线的时间与使用流水线的时间之比 s = 不使用流水线的时间 / 使用流水线的时间 存储层次化的存储结构从外存、内存、cache、寄存器，速度越来越高，容量越来越小。 CacheCache的功能：提高 CPU 数据输入输出的速率，突破 CPU 与存储系统间数据传送带宽限制。 Cache 是计算机存储系统中访问最快的层次 使用 Cache 改善系统性能的依据是程序的局部性原理 使用 Cache + 主存储器的系统的平均周期t = h * t1 + (1-h) * t2 h ：CPU对 Cache 的访问命中率， t1：Cache 的周期时间 t2：主存储器的周期时间 局部性原理 时间局部性 对刚刚访问的程序再进行访问，如循环体程序，这时就将这些都放入 Cache 中 空间局部性 对相邻的地址依次访问，如变量数组，也会将其放入 Cache 中 工作集理论：工作集是进程运行时被频繁访问的页码集合 主存分类 只读存储器（ROM） 断电存储内容不消失 随机存储器（RAM） 断电存储内容消失 编址例题： 内存地址从AC000H到C7FFFH,共有（）KB个地址单元，如果该内存地址按字（16bit）编址，由28块芯片构成。已知构成此内存的芯片每片有16KB个存储单元，则该芯片每个存储单元存储（）位 解答： 将内存大地址减去小地址再加1就是内存地址，即C7FFFH-AC000H+1=1C000H(给7加的是16，因为是16进制)， 十六进制（1C000）16=2^16+2^15+2^14=64K+32K+16K=112K. 注意此处按字编址。需要构成的内存为112K16b,使用28块芯片构成该内存，则每个芯片的容量应为4K16B。已知构成此内存的芯片每片有16K个存储单元，因此该芯片每个存储单元存储4位二进制 磁盘结构与参数存取时间 = 寻道时间 + 等待时间 寻道时间： 磁头移动到磁道所需要的时间 等待时间： 等待要读写的扇区转动到磁头下面的时间 总线 内部总线（芯片级别） 系统总线（线路板级别） 数据总线 地址总线 控制总线 外部总线（外设级别） 可靠性分析串联系统和并联系统串联可靠度：R = R1 R2 R3 … Rn 失效度： S = S1 + S2 + S3 + … + Sn 并联可靠度： R = 1 - (1 - R1) (1 - R2) … * (1 - Rn) 失效度：S = 1 - R 差错控制循环校验码 CRC 可以检错，不能纠错 重点 海明码 既可以检错，又可以纠错 重点]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端轮播图]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[要求 自动轮播且无缝 点要随着图片的轮播而同步改变 图片的轮播可以随手指的滑动而改变 手指滑动距离小于屏幕的 1/3 吸附回去 手指滑动距离大于屏幕的 1/3 切换下一张或上一张图片 html注意： 第一张图片之前重复最后一张，最后一种之后重复第一张 123456789101112131415161718192021222324&lt;div class="jd_banner"&gt; &lt;ul class="clearFix"&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l8.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l1.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l2.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l3.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l4.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l5.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l6.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l7.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l8.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/l1.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li class="now"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114let banner = function () &#123; /* 获取元素 */ let banner = document.querySelector('.jd_banner') let width = banner.offsetWidth let imageBox = banner.querySelector('ul:first-child') let pointBox = banner.querySelector('ul:last-child') let points = pointBox.querySelectorAll('li') let addTransition = function () &#123; imageBox.style.transition = 'all 0.2s' imageBox.style.webkitTransition = 'all 0.2s' &#125; let removeTransition = function () &#123; imageBox.style.transition = 'none' imageBox.style.webkitTransition = 'none' &#125; let setTranslateX = function (translateX) &#123; imageBox.style.transform = 'translateX(' + translateX + 'px)' imageBox.style.webkitTransform = 'translateX(' + translateX + 'px)' &#125; let index = 1 let timer = setInterval(()=&gt;&#123; index++ addTransition() setTranslateX(-index * width) &#125;, 1000); /* 判断是否要移动到第一张 */ imageBox.addEventListener('transitionend', ()=&gt;&#123; if (index &gt;= 9) &#123; index = 1 /* 清除过渡 */ removeTransition() /* 移动 */ setTranslateX(-index * width) &#125; else if (index &lt;= 0) &#123; index = 8; removeTransition() setTranslateX(-index * width) &#125; setPoint() &#125;) /* 焦点移动方法 */ let setPoint = function () &#123; // 伪数组转换成真数组 let arr = Array.from(points) arr.forEach((item)=&gt;&#123; item.classList.remove('now') &#125;) points[index - 1].classList.add('now') &#125; /* 手指触摸移动事件 ---》元素随手中移动距离的改变而改变 */ let startX = 0; let distanceX = 0 let isMove = false imageBox.addEventListener('touchstart', (e)=&gt;&#123; // 清除定时器 clearInterval(timer) // 记录触摸点的 X 坐标 startX = e.touches[0].clientX; &#125;) imageBox.addEventListener('touchmove', (e)=&gt;&#123; // 记录滑动中的 X 坐标 let moveX = e.touches[0].clientX // 计算滑动距离 distanceX = moveX - startX; // 元素移动的距离 = 当前的位置 + 滑动的距离 let translateX = -index * width + distanceX // 元素在跟随手指移动是不需要原来的动画过渡 removeTransition() setTranslateX(translateX) isMove = true &#125;) imageBox.addEventListener('touchend', (e) =&gt; &#123; /* 用滑动的距离是否小于 1/3 来判断是否切换图片 */ if (isMove) &#123; if (Math.abs(distanceX) &lt; width / 3) &#123; addTransition() setTranslateX(-index * width) &#125; else &#123; // 右滑动，切换上一张 if (distanceX &gt; 0) &#123; index-- &#125; else &#123; index++ &#125; addTransition() setTranslateX(-index * width) &#125; &#125; /* 重置参数 */ startX = 0 distanceX = 0 isMove = false /* 开启定时器 */ clearInterval(timer) timer = setInterval(() =&gt; &#123; index++ addTransition() setTranslateX(-index * width) &#125;, 1000); &#125;)&#125;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>轮播图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap 常见组件]]></title>
    <url>%2F2019%2F03%2F06%2Fbootstrap%E5%B8%B8%E8%A7%81%E7%BB%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[栅格系统.container 容器响应式布局容器 用法： 123&lt;div class= 'container'&gt; 响应式内容&lt;/div&gt; .container 容器默认有 15px 的左右内间距 栅格系统栅格系统就是行列布局 行： row.row 可以填充 .container 的 15px 的内边距，因为设置了 margin-left，margin-right = 15px 用来填充 .container 容器的内边距 列 : col使用样式 1col-参数1-参数2 参数1： 参数值 作用范围 lg 大屏以上设备生效 md 中屏以上设备生效 sm 小屏以上设备生效 xs 超小屏以上设备生效 参数2： 每一行的等分数，默认 12 等分，是几就占几份（取值 1–12） 列子 12345678910111213141516171819202122232425&lt;style&gt; .container&#123; height: 100px; background: hotpink; &#125; .row&#123; height: 50px; background: pink; &#125; .row &gt; div&#123; height: 25px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-3"&gt;&lt;/div&gt; &lt;div class="col-md-4"&gt;&lt;/div&gt; &lt;div class="col-md-5"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 列偏移col-参数1-offset-参数2 栅格向右偏移 多少份（ 参数和上面相同） 123&lt;div class = 'col-xm-6 col-xm-offset-1'&gt; &lt;/div&gt; 列排序 col-参数1-push-参数2 向右移动 col-参数1-pull-参数2 向左移动 导航条（navBar) 组件因为导航条中用到了 Collapse 组件 所以先要了解 collapsed 组件 Collapse 组件Collapse 组件作用时 控制其他元素的展开或隐藏 data-toggle=”collapse” 组件类型申明 为 collapse （坍塌） data-target=”.box” 控制目标为 .box的选择器的元素 在 a 标签中 data-target 可以 直接用 href 替换 1234567891011&lt;button data-toggle="collapse" data-target=".box" aria-expander='false'&gt;切换&lt;/button&gt; &lt;a href=".box" data-toggle="collapse"&gt;切换&lt;/a&gt; &lt;div class="box"&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; 内容&lt;br&gt; &lt;/div&gt; navBar组件分析 aria-expanded=”false” 用于屏幕阅读器使用，（提示有一个没有展开的区域） class=”sr-only” 仅用于屏幕阅读器阅读，里面的内不会显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;nav class="navbar navbar-default"&gt; &lt;!-- 采用流式布局 --&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;!-- 以下为三个字体图标，共同组成了一个显示按钮 --&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 这是商标区域--&gt; &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!--以下的 链接、表单、其他内容被上面的按钮切换 --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 轮播bootstrap 轮播图分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- carousel 轮播图的模块 slide是否加上滑动效果 --&gt;&lt;!-- data-ride="carousel" 初始化轮播图属性--&gt;&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- 点盒子 --&gt; &lt;ol class="carousel-indicators"&gt; &lt;!-- data-target="#carousel-example-generic" 控制目标轮播图 data-slide-to="0" 控制的是轮播图当中的第几张 （索引） class="active" 当前选中的点 --&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- 图片盒子 --&gt; &lt;!-- role="listbox" 提供给屏幕阅读器使用 --&gt; &lt;div class="carousel-inner"&gt; &lt;!--需要轮播的容器--&gt; &lt;div class="item active"&gt; &lt;!--图片--&gt; &lt;img src="..." alt="..."&gt; &lt;!--说明--&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- 上一张下一张按钮 --&gt; &lt;!-- data-slide="prev" data-slide="next" href="#carousel-example-generic" 控制目标轮播图 --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 缺点：在移动端图片显示太过于 扁长 ，显示有缺陷，图片大小修改会造成显示问题 修改pc端显示效果将 img 标签的图片修改成 background 来显示，这样可以控制图片大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;style&gt; .pcimg_box&#123; height: 400px; width: 100%; display: block; background-size: cover; background-position: center; background-repeat: no-repeat; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;!-- 指示器（焦点） --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="3"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_01_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_02_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_03_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;a href="" class="pcimg_box" style="background-image:url('../微金所/images/slide_04_2000x410.jpg')"&gt;&lt;/a&gt; &lt;/div&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 需要将背景图片写在行内样式中，方便后端渲染 标签页12345678910111213141516&lt;!-- 页签 --&gt; &lt;ul class="nav nav-tabs" role="tablist"&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#home" aria-controls="home" role="tab" data-toggle="tab"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#profile" aria-controls="profile" role="tab" data-toggle="tab"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#messages" aria-controls="messages" role="tab" data-toggle="tab"&gt;Messages&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#settings" aria-controls="settings" role="tab" data-toggle="tab"&gt;Settings&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- Tab panes --&gt; &lt;div class="tab-content"&gt; &lt;div role="tabpanel" class="tab-pane active" id="home"&gt;1&lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="profile"&gt;2&lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="messages"&gt;3&lt;/div&gt; &lt;div role="tabpanel" class="tab-pane" id="settings"&gt;4&lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的获取和转换]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据的获取和转换获取页面 url 通过问号传参传递的样式为： 1http://localhost:3000/m/searchList.html?key=1&amp;name=10 获取： 1234567891011121314var getParamsByUrl = function () &#123; var params = &#123;&#125; var search = location.search //"?key=1&amp;name=10" if (search) &#123; search = search.replace('?', '') //"key=1&amp;name=10" var arr = search.split('&amp;') //["key=1", "name=10"] arr.forEach(function (item, i) &#123; var itemArr = item.split('=') //["key", "1"] ["name", "10"] params[itemArr[0]] = itemArr[1] //&#123;key: "1", name: "10"&#125; &#125;) &#125; return params; &#125;var params = getParamsByUrl() node 获取 get 和 post 参数获取 get 参数直接从url 中获取 使用 req.rul 1234let server = http.createServer((req, res) =&gt; &#123; console.log(req.url);// /data.js?username=se&amp;pwd=d res.end()&#125;) 以对象形式获取 引入 url 核心模块 1let url = require('rul') 给 url使用parse 方法解析 req.url 1234let server = http.createServer((req, res) =&gt; &#123; let obj = url.parse(req.url) console.log(obj); res.end() 解析结果为 12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?username=se&amp;pwd=f', query: 'username=se&amp;pwd=f', pathname: '/data.js', path: '/data.js?username=se&amp;pwd=f', href: '/data.js?username=se&amp;pwd=f' &#125; 此时的 query 属性还是 字符串形式，如果给 parse 方法传入第二个参数：true，则结果为 12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?username=se&amp;pwd=deee', query: [Object: null prototype] &#123; username: 'se', pwd: 'deee' &#125;, pathname: '/data.js', path: '/data.js?username=se&amp;pwd=deee', href: '/data.js?username=se&amp;pwd=deee' &#125; 这时的 query 属性值为一个对象 获取 post 提交参数post 提交的参数在请求体中，获取请求体是以分组报文的形式获取，所以 post 里面的参数不能直接一次性获取 12345678910111213141516171819const http = require('http')//解析传来的参数为 jsonconst queryString = require('querystring')let server = http.createServer((req, res) =&gt; &#123; let str = '' // 监听每一部分报文到达，将每一次的报文拼装 req.on('data', data=&gt; &#123; str +=data &#125;) //全部传输完毕 req.on('end', ()=&gt; &#123; let post = queryString.parse(str) console.log(str); // username=se&amp;pwd=fgd [Object: null prototype] &#123; username: 'se', pwd: 'fgd' &#125; res.end() &#125;)&#125;)server.listen(8888) 这种方式只可以获取普通编码数据，不能获取二进制文件，因为二进制转换成字符串，再转换回去格式会被破坏 url.parse 和queryString.parse 区别 url.parse()解析的是整个 url 如：/data.js?username=se&amp;pwd=f querystring.parse()解析的是 参数 如：username=se&amp;pwd=f 封装成都可以获取12345678910111213141516171819202122const http = require('http')const url = require('url')const querystring = require('querystring')let server = http.createServer((req, res) =&gt; &#123; // 获取get参数 let &#123;pathname, query&#125; = url.parse(req.url,true) // 获取post 参数 let str ='' req.on('data', data =&gt; &#123; str += data &#125;) req.on('end', () =&gt; &#123; let post = querystring.parse(str) console.log(pathname, query, post); &#125;) res.end() &#125;)server.listen(3000)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>数据，node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板引擎使用步骤]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[模板引擎渲染步骤 获取数据 定义模板 调用模板 返回 html 1. 用 jQuery 发送 get请求，获取数据123456789101112var getFirstCategoryData = function (callback) &#123; $.ajax(&#123; url: '/category/queryTopCategory', type: 'get', data: '', dataType: 'json', success: function (data) &#123; callback &amp;&amp; callback(data) &#125; &#125;);&#125; 后台返回的json数据 12345678&#123;total: 5, rows: Array(5)&#125;rows: Array(5)0: &#123;id: 1, categoryName: "运动馆", isDelete: 1&#125;1: &#123;id: 2, categoryName: "女士馆", isDelete: 1&#125;2: &#123;id: 3, categoryName: "男士馆", isDelete: 1&#125;3: &#123;id: 4, categoryName: "帆布馆", isDelete: 1&#125;4: &#123;id: 5, categoryName: "户外管", isDelete: 1&#125;length: 5 2. 定义模板12345&lt;script type="text/template" id="firstTemplate"&gt; &lt;% for(var i = 0; i &lt; rows.length; i++) &#123; %&gt; &lt;li class="&lt;%= i==0?'now':''%&gt;"&gt;&lt;a href="javascript:;" data-id = "&lt;%=rows[i].id%&gt;"&gt; &lt;%=rows[i].categoryName%&gt;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/script&gt; 3. 调用模板,进行渲染123getFirstCategoryData(function (data) &#123; $('.cate_left ul').html(template('firstTemplate',data)) &#125;) 4. 渲染结果1234567891011&lt;ul&gt; &lt;li class="now"&gt;&lt;a href="javascript:;" data-id="1"&gt;运动馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="2"&gt;女士馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="3"&gt;男士馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="4"&gt;帆布馆&lt;/a&gt;&lt;/li&gt; &lt;li class=""&gt;&lt;a href="javascript:;" data-id="5"&gt;户外馆&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>ajax</tag>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less常见语法]]></title>
    <url>%2F2019%2F03%2F03%2Fless%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Less安装less1npm i -g less less 文件编译成 css 文件手动编译 1lessc less文件.less 编译后的css文件.css vscode 自动编译 安装插件 Ease Less 变量申明变量 必须@ 前缀 : 相当于 等号 ，必须; 结束。 必须符合变量的命名规则。 1@mainColor: #ccc; 使用变量123a:hover&#123; color:@mainColor;&#125; 编译结果 123a:hover&#123; color:#ccc;&#125; 注意：less 文件开头 指定编码为 UTF-8 编码 1@charset "UTF-8" Mixin 混入类混入less 语法 12345678910.w50&#123; width: 50%;&#125;.f_left&#123; float: left;&#125;.w50-f_left&#123; .w50(); .f_left();&#125; 编译成 css 12345678910.w50 &#123; width: 50%;&#125;.f_left &#123; float: left;&#125;.w50-f_left &#123; width: 50%; float: left;&#125; 编译的 css 会出现混入前的类 函数混入less 语法 12345678910.w50()&#123; width: 50%;&#125;.f_left()&#123; float: left;&#125;.w50-f_left&#123; .w50(); .f_left()&#125; 编译成 css 。 1234.w50-f_left &#123; width: 50%; float: left;&#125; 编译后的 css 不会出现函数本体。 带参函数混入 定义了参数（没有默认值）调用的时候必须传参。 定义 默认值的方式和定义变量相同。 定义了参数（有默认值），调用的时候可以不用传参。 less 语法 12345678.f(@direction: left) &#123; float:@direction;&#125;.r_left&#123; .f(); .f(right)&#125; 编译的 css 1234.r_left &#123; float: left; float: right;&#125; 嵌套为了使 css 的层次更加清楚 ，less 可以像 html一样进行类似的嵌套写法 less语法 1234567891011121314.top_bar&#123; position: relative; img&#123; display: block; position: absolute; top: 0; left: 0; &#125; &amp;::after&#123; content: ""; display: block; &#125;&#125; 编译后的 css 12345678910.top_bar img &#123; display: block; position: absolute; top: 0; left: 0;&#125;.top_bar::after &#123; content: ""; display: block;&#125; 注意：伪类和伪元素等需要和前面的选择器紧挨使用的 需要用&amp;符号进行连接否则编译后会有空格。 Import（导入）less 可以进行模块化，最后可以用 import 进行导入组合 variables.less 的内容 123456789@mainColor:#ccc;@box: box;a:hover&#123; color: @mainColor;&#125;.@&#123;box&#125; &#123; color:@mainColor;&#125; 在 main.less 中导入 variables.less 1@import "variables"; 编译的 css 文件 123456a:hover &#123; color: #ccc;&#125;.box &#123; color: #ccc;&#125; 运算less 支持数字的简单运算 1234567@num:7;ul&#123; width: 100% * @num; li&#123; width: 100% / @num; &#125;&#125; 编译后的css 123456ul &#123; width: 700%;&#125;ul li &#123; width: 14.28571429%;&#125;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem+less适配]]></title>
    <url>%2F2019%2F03%2F03%2Frem-less%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[rem 和 emrem和 em都是相对单位 区别 em 是基于父容器的字体大小 rem 是基于根元素（也就是 html 元素）的字体大小 rem 适配常见的适配方案 名称 缺点 伸缩布局 元素只能宽度适配 流式布局 元素只能宽度适配 响应式布局 元素只能宽度适配 rem 布局 高度和宽度可以同时适配 rem 适配原理页面的尺寸都用 rem 作为单位，针对不同大小的页面只需要更改 基准值 html 的大小即可实现适配 rem 基准值的换算公式当前设备 rem 基准值 = 预设的基准值 / 设计稿的宽度 * 当前设备的宽度 当前的设备： 设备宽度为 640px ，当前的 div 为 640px 100px，预设基准为 100px ，所以div 大小可以转换为 6.4rem 1rem 适配的设备： 设备宽度为 320px ，div 的大小为 6.4rem * 1rem，要想div的尺寸实现适配，需要修改当前的 rem 基准值。 由上面的公式可以算出： 100 / 640 * 320 = 50px。 所以需要修改当前的 基准值为 50px less + rem 实现多种设备的适配根据 rem 的适配原理，可以知道是根据设备的宽度不同来改变 html 元素的字体大小来进行适配。所以如果根据当前设备宽度来改变 html 元素的字体大小呢？ 方式一：媒体查询 同时适配 640px 和 320px 的设备 1234567891011121314151617181920212223242526272829&lt;style&gt; @media (min-width:320px) &#123; html&#123; font-size: 50px; &#125; &#125; @media (min-width: 640px) &#123; html&#123; font-size: 100px; &#125; &#125; body&#123; margin: 0; padding: 0; &#125; header&#123; width: 100%; height: 1rem; line-height: 1rem; font-size: 0.32rem; text-align: center; background-color: green; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;购物车&lt;/header&gt;&lt;/body&gt; 随着设备的增多，媒体查询和基准值的计算会不方便同时也不好维护，所以可以通过 less 进行改进 方式二：less 定义存储变量的less 文件 var.less 123456789101112@charset "UTF-8";//变量// 通过 less 定义数组，存储主流设备的尺寸@adapterDeviceList:750px, 720px, 640px, 540px, 480px, 424px, 414px, 400px, 384px, 375px, 360px, 320px;// 设计稿尺寸@psdWidth: 750px;// 预设基准值@baseFontSize: 100px;// 设备的种类（数组的长度）// 通过内置函数 length来获取@len: length(@adapterDeviceList); 设置一个适配的less 文件 mixins.less 这个less文件通过递归来生成不同的媒体查询 less 没有循环语法 when （此处是函数的执行条件） 内置函数 extract（）用于获取数组里面的元素，传入两个参数，一个是数组名称，另一个时序号 下面的函数是倒着获取数组元素，生成媒体插叙的函数 123456789.adapterMixins(@index) when(@index &gt; 0) &#123; @media (min-width: extract(@adapterDeviceList, @index)) &#123; html&#123; font-size: @baseFontSize / @psdWidth * extract(@adapterDeviceList, @index); &#125; &#125; .adapterMixins(@index - 1);&#125;.adapterMixins(@len); 设置一个less 文件用于引入上面的less文件的 index.less 12@import "var.less";@import "mixins.less"; 编译 index.less 后引入到html文件即可]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>less</tag>
        <tag>rem</tag>
      </tags>
  </entry>
</search>
